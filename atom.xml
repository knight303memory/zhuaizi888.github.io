<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Killua&#39;s blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://tusko.cn/"/>
  <updated>2017-11-11T10:11:00.000Z</updated>
  <id>http://tusko.cn/</id>
  
  <author>
    <name>Killua</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux知识点小结</title>
    <link href="http://tusko.cn/2017/11/11/Linux%E7%9F%A5%E8%AF%86%E7%82%B9%E5%B0%8F%E7%BB%93/"/>
    <id>http://tusko.cn/2017/11/11/Linux知识点小结/</id>
    <published>2017-11-11T08:55:26.000Z</published>
    <updated>2017-11-11T10:11:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>&#160; &#160; &#160; &#160;本文对秋招准备过程中零碎知识点总结，仅供参考</p>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><h4 id="硬链接与软链接"><a href="#硬链接与软链接" class="headerlink" title="硬链接与软链接"></a>硬链接与软链接</h4><p>【硬连接】<br>&#160; &#160; &#160; &#160;硬连接指通过索引节点来进行连接。在Linux的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号(Inode Index)。在Linux中，多个文件名指向同一索引节点是存在的。一般这种连接就是硬连接。硬连接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，以防止“误删”的功能。其原因如上所述，因为对应该目录的索引节点有一个以上的连接。只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。也就是说，文件真正删除的条件是与之相关的所有硬连接文件均被删除。<br>【软连接】<br>&#160; &#160; &#160; &#160;另外一种连接称之为符号连接（Symbolic Link），也叫软连接。软链接文件有类似于Windows的快捷方式。它实际上是一个特殊的文件。在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。</p>
<h4 id="Linux进程状态"><a href="#Linux进程状态" class="headerlink" title="Linux进程状态"></a>Linux进程状态</h4><p>R：正在运行；<br>S：睡眠；<br>T：正在检测或停止；<br>Z：已终止，但父进程无法正常终止它，成了“僵尸”进程。</p>
<h4 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h4><p><strong>地址从低到高：</strong><br>代码段(.text)：用来存放可执行文件的机器指令。存放在只读区域，以防止被修改。<br>只读数据段(.rodata)：用来存放常量存放在只读区域，如字符串常量、全局const变量等。<br>可读写数据段(.data)：用来存放可执行文件中已初始化全局变量，即静态分配的变量和全局变量。<br>BSS段(.bss)：未初始化的全局变量和局部静态变量一般放在.bss的段里，以节省内存空间。<br>堆：用来容纳应用程序动态分配的内存区域。当程序使用malloc或new分配内存时，得到的内存来自堆。堆通常位于栈的下方。<br>栈：用于维护函数调用的上下文。栈通常分配在用户空间的最高地址处分配。<br>动态链接库映射区：如果程序调用了动态链接库，则会有这一部分。该区域是用于映射装载的动态链接库。<br>保留区：内存中受到保护而禁止访问的内存区域。</p>
<h4 id="Shell编程"><a href="#Shell编程" class="headerlink" title="Shell编程"></a>Shell编程</h4><p>-f “filename”<br>判断是否是一个文件<br>-x “/bin/ls”<br>判断/bin/ls是否存在并有可执行权限<br>-n “\$ var”<br>判断 \$var 变量是否有值</p>
<h4 id="进程和线程优缺点"><a href="#进程和线程优缺点" class="headerlink" title="进程和线程优缺点"></a>进程和线程优缺点</h4><p>进程优点：编程、调试简单，可靠性较高。<br>进程缺点：创建、销毁、切换速度慢，内存、资源占用大。<br>线程优点：创建、销毁、切换速度快，内存、资源占用小。<br>线程缺点：编程、调试复杂，可靠性较差。</p>
<p>进程的优点：<br>1）顺序程序的特点：具有封闭性和可再现性;<br>2）程序的并发执行和资源共享。多道程序设计出现后，实现了程序的并发执行和资源共享，提高了系统的效率和系统的资源利用率。</p>
<p>进程的缺点：<br>操作系统调度切换多个线程要比切换调度进程在速度上快的多。而且进程间内存无法共享，通讯也比较麻烦。<br>线程之间由于共享进程内存空间，所以交换数据非常方便;在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销。</p>
<p>线程的优点：<br>1）它是一种非常”节俭”的多任务操作方式。在Linux系统下，启动一个新的进程必须分配给它独立的地址空间，建立众多的数据表来维护它的代码段、堆栈段和数据段，这是一种”昂贵”的多任务工作方式。而运行于一个进程中的多个线程，它们彼此之间使用相同的地址空间，共享大部分数据，启动一个线程所花费的空间远远小于启动一个进程所花费的空间，而且，线程间彼此切换所需的时间也远远小于进程间切换所需要的时间。当然，在具体的系统上，这个数据可能会有较大的区别;<br>2）线程间方便的通信机制，由于同一进程下的线程之间共享数据空间，所以一个线程的数据可以直接为其它线程所用，这不仅快捷，而且方便;<br>3）使多CPU系统更加有效。操作系统会保证当线程数不大于CPU数目时，不同的线程运行于不同的CPU上;<br>4）改善程序结构。一个既长又复杂的进程可以考虑分为多个线程，成为几个独立或半独立的运行部分，这样的程序会利于理解和修改。<br>线程的缺点：<br>1）调度时, 要保存线程状态，频繁调度, 需要占用大量的机时;<br>2）程序设计上容易出错（线程同步问题）。</p>
<p>多线程的优点：<br>无需跨进程边界;<br>程序逻辑和控制方式简单;<br>所有线程可以直接共享内存和变量等;<br>线程方式消耗的总资源比进程方式好;</p>
<p>多线程缺点：<br>每个线程与主程序共用地址空间，受限于2GB地址空间;<br>线程之间的同步和加锁控制比较麻烦;<br>一个线程的崩溃可能影响到整个程序的稳定性;<br>到达一定的线程数程度后，即使再增加CPU也无法提高性能，例如Windows Server 2003，大约是1500个左右的线程数就快到极限了（线程堆栈设定为1M），如果设定线程堆栈为2M，还达不到1500个线程总数;<br>线程能够提高的总性能有限，而且线程多了之后，线程本身的调度也是一个麻烦事儿，需要消耗较多的CPU</p>
<p>多进程优点：<br>每个进程互相独立，不影响主程序的稳定性，子进程崩溃没关系;<br>通过增加CPU，就可以容易扩充性能;<br>可以尽量减少线程加锁/解锁的影响，极大提高性能，就算是线程运行的模块算法效率低也没关系;<br>每个子进程都有2GB地址空间和相关资源，总体能够达到的性能上限非常大</p>
<p>多进程缺点：<br>逻辑控制复杂，需要和主程序交互;<br>需要跨进程边界，如果有大数据量传送，就不太好，适合小数据量传送、密集运算<br>多进程调度开销比较大;<br>最好是多进程和多线程结合，即根据实际的需要，每个CPU开启一个子进程，这个子进程开启多线程可以为若干同类型的数据进行处理。当然你也可以利用多线程+多CPU+轮询方式来解决问题……<br>方法和手段是多样的，关键是自己看起来实现方便有能够满足要求，代价也合适。</p>
<h4 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h4><p><strong>select / epoll</strong></p>
<p>select的两个缺点：</p>
<ul>
<li>能监听端口的大小有限。默认是1024个</li>
<li>可采用轮询的方法，效率较低</li>
</ul>
<p>epoll的优点</p>
<ul>
<li>能打开的FD的上限远大于1024（1G的内存上能监听约10万个端口）；</li>
<li>不是轮询的方式，不会随着FD数目的增加效率下降。只有活跃可用的FD才会调用callback函数；</li>
<li>利用mmap()文件映射内存加速与内核空间的消息传递；</li>
</ul>
<p>&#160; &#160; &#160; &#160;LT(level triggered)是缺省的工作方式，并且同时支持block和no-block socket.在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你的，所以，这种模式编程出错误可能性要小一点。传统的select/poll都是这种模型的代表。</p>
<p>&#160; &#160; &#160; &#160;ET(edge-triggered)是高速工作方式，只支持no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了(比如，你在发送，接收或者接收请求，或者发送接收的数据少于一定量时导致了一个EWOULDBLOCK 错误）。但是请注意，如果一直不对这个fd作IO操作(从而导致它再次变成未就绪)，内核不会发送更多的通知(only once),不过在TCP协议中，ET模式的加速效用仍需要更多的benchmark确认。</p>
<p>在非阻塞式IO中，用户进程其实是需要不断的主动询问kernel数据准备好了没有。</p>
<p>在非阻塞状态下，recv() 接口在被调用后立即返回，返回值代表了不同的含义。如在本例中，</p>
<ul>
<li>recv() 返回值大于 0，表示接受数据完毕，返回值即是接受到的字节数；</li>
<li>recv() 返回 0，表示连接已经正常断开；</li>
<li>recv() 返回 -1，且 errno 等于 EAGAIN，表示 recv 操作还没执行完成；</li>
<li>recv() 返回 -1，且 errno 不等于 EAGAIN，表示 recv 操作遇到系统错误 errno。</li>
</ul>
<p>循环调用recv()将大幅度推高CPU 占用率；此外，在这个方案中recv()更多的是起到检测“操作是否完成”的作用，实际操作系统提供了更为高效的检测“操作是否完成“作用的接口，例如select()多路复用模式，可以一次检测多个连接是否活跃。</p>
<p>select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。</p>
<p>当用户进程调用了select，那么整个进程会被block，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。</p>
<p>如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。</p>
<p>在多路复用模型中，对于每一个socket，一般都设置成为non-blocking，但是,整个用户的process其实是一直被block的。只不过process是被select这个函数block，而不是被socket IO给block。因此select()与非阻塞IO类似。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明&quot;&gt;&lt;/a&gt;说明&lt;/h3&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;本文对秋招准备过程中零碎知识点总结，仅供参考&lt;/p&gt;
&lt;h3 id=&quot;正文&quot;&gt;&lt;a h
    
    </summary>
    
      <category term="Linux" scheme="http://tusko.cn/categories/Linux/"/>
    
    
      <category term="总结" scheme="http://tusko.cn/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="Linux" scheme="http://tusko.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Qt信号槽（转引）</title>
    <link href="http://tusko.cn/2017/11/11/Qt%E4%BF%A1%E5%8F%B7%E6%A7%BD/"/>
    <id>http://tusko.cn/2017/11/11/Qt信号槽/</id>
    <published>2017-11-11T06:26:47.000Z</published>
    <updated>2017-11-11T08:45:34.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Qt信号槽机制"><a href="#Qt信号槽机制" class="headerlink" title="Qt信号槽机制"></a>Qt信号槽机制</h3><p>引用转载 <a href="http://blog.csdn.net/qter_wd007/article/details/5598264" target="_blank" rel="external">http://blog.csdn.net/qter_wd007/article/details/5598264</a><br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<a href="http://blog.csdn.net/qq_16952303/article/details/51585577" target="_blank" rel="external">http://blog.csdn.net/qq_16952303/article/details/51585577</a></p>
<p>&#160; &#160; &#160; &#160;在我们所了解的其它GUI工具包中，窗口小部件(widget)都有一个回调函数用于响应它们触发的动作，这个回调函数通常是一个指向某个函数的指针。在Qt中用信号和槽取代了上述机制。</p>
<h4 id="1-信号（signal）"><a href="#1-信号（signal）" class="headerlink" title="1.信号（signal）"></a>1.信号（signal）</h4><p>&#160; &#160; &#160;当对象的状态发生改变时，信号被某一个对象发射（emit）。只有定义过这个信号的类或者其派生类能够发射这个信号。当一个信号被发射时，与其相关联的槽将被执行，就象一个正常的函数调用一样。信号-槽机制独立于任何GUI事件循环。只有当所有的槽正确返回以后，发射函数（emit）才返回。</p>
<p>&#160; &#160; &#160; 如果存在多个槽与某个信号相关联，那么，当这个信号被发射时，这些槽将会一个接一个地被执行，但是它们执行的顺序将会是不确定的，并且我们不能指定它们执行的顺序。</p>
<p>&#160; &#160; &#160; 信号的声明是在头文件中进行的，并且moc工具会注意不要将信号定义在实现文件中。Qt用signals关键字标识信号声明区，随后即可声明自己的信号。例如，下面定义了几个信号：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">signals: </div><div class="line">void yourSignal();</div><div class="line">void yourSignal(int x);</div></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; 信号和槽函数的声明一般位于头文件中，同时在类声明的开始位置必须加上Q_OBJECT语句，这条语句是不可缺少的，它将告诉编译器在编译之前必须先应用moc工具进行扩展。关键字signals指出随后开始信号的声明，这里signals用的是复数形式而非单数，siganls没有public、private、protected等属性，这点不同于slots。另外，signals、slots关键字是QT自己定义的，不是C++中的关键字。</p>
<p>&#160; &#160; &#160; 还有，信号的声明类似于函数的声明而非变量的声明，左边要有类型，右边要有括号，如果要向槽中传递参数的话，在括号中指定每个形式参数的类型，当然，形式参数的个数可以多于一个。</p>
<p>&#160; &#160; &#160; 从形式上讲,信号的声明与普通的C++函数是一样的，但是信号没有定义函数实现。另外，信号的返回类型都是void，而C++函数的返回值可以有丰富的类型。</p>
<p>&#160; &#160; &#160; 注意，signal 代码会由 moc自动生成，moc将其转化为标准的C++语句，C++预处理器会认为自己处理的是标准C++源文件。所以大家不要在自己的C++实现文件实现signal。</p>
<h4 id="2-槽（slot）"><a href="#2-槽（slot）" class="headerlink" title="2.槽（slot）"></a>2.槽（slot）</h4><p>&#160; &#160; &#160; 槽是普通的C++成员函数，可以被正常调用，不同之处是它们可以与信号（signal）相关联。当与其关联的信号被发射时，这个槽就会被调用。槽可以有参数，但槽的参数不能有缺省值。</p>
<p>&#160; &#160; &#160; 槽也和普通成员函数一样有访问权限。槽的访问权限决定了谁可以和它相连。通常，槽也分为三种类型，即public slots、private slots和protected slots。</p>
<p>&#160; &#160; &#160; public slots：在这个代码区段内声明的槽意味着任何对象都可将信号与之相连接。这对于组件编程来说非常有用：你生成了许多对象，它们互相并不知道，把它们的信号和槽连接起来，这样信息就可以正确地传递，并且就像一个小孩子喜欢玩耍的铁路轨道上的火车模型，把它打开然后让它跑起来。</p>
<p>&#160; &#160; &#160;   protected slots：在这个代码区段内声明的槽意味着当前类及其子类可以将信号与之相关联。这些槽只是类的实现的一部分，而不是它和外界的接口。</p>
<p>&#160; &#160; &#160;  private slots：在这个代码区段内声明的槽意味着只有类自己可以将信号与之相关联。这就是说这些槽和这个类是非常紧密的，甚至它的子类都没有获得连接权利这样的信任。</p>
<p>&#160; &#160; &#160;  通常，我们使用public和private声明槽是比较常见的，建议尽量不要使用protected关键字来修饰槽的属性。此外，槽也能够声明为虚函数。</p>
<p>&#160; &#160; &#160;  槽的声明也是在头文件中进行的。例如，下面声明了几个槽：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public slots:</div><div class="line">void yourSlot();</div><div class="line">void yourSlot(int x);</div></pre></td></tr></table></figure>
<h4 id="3-信号与槽的关联"><a href="#3-信号与槽的关联" class="headerlink" title="3.信号与槽的关联"></a>3.信号与槽的关联</h4><p>&#160; &#160; &#160;槽和普通的C++成员函数几乎是一样的－可以是虚函数；可以被重载；可以是共有的、保护的或是私有的，并且也可以被其它C++成员函数直接调用；还有，它们的参数可以是任意类型。唯一不同的是：槽还可以和信号连接在一起，在这种情况下，每当发射这个信号的时候，就会自动调用这个槽。</p>
<p>connect()语句看起来会是如下的样子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">connect(sender,SIGNAL(signal),receiver,SLOT(slot));</div></pre></td></tr></table></figure>
<p>&#160; &#160; &#160;实际上还有一个默认参数，即槽的连接方式为自动方式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">QMetaObject::Connection QObject::connect(const QObject * sender, const char * signal, const QObject * receiver, const char * method, Qt::ConnectionType type = Qt::AutoConnection)</div></pre></td></tr></table></figure>
<p>&#160; &#160; &#160;</p>
<blockquote>
<ol>
<li>Auto Connection (default) If the signal is emitted in the thread which the receiving object has affinity then the behavior is the same as the Direct Connection. Otherwise, the behavior is the same as the Queued Connection.”</li>
<li>Direct Connection The slot is invoked immediately, when the signal is emitted. The slot is executed in the emitter’s thread, which is not necessarily the receiver’s thread.</li>
<li>Queued Connection The slot is invoked when control returns to the event loop of the receiver’s thread. The slot is executed in the receiver’s thread.</li>
<li>Blocking Queued Connection The slot is invoked as for the Queued Connection, except the current thread blocks until the slot returns.<br>Note: Using this type to connect objects in the same thread will cause deadlock.</li>
<li>Unique Connection The behavior is the same as the Auto Connection, but the connection is made only if it does not duplicate an existing connection. i.e., if the same signal is already connected to the same slot for the same pair of objects, then the connection is not made and connect() returns false</li>
</ol>
</blockquote>
<p>一共是5个值:自动、直接、队列、阻塞队列、唯一</p>
<ol>
<li>直接连接的大概意思是：信号一旦发射，槽立即执行，并且槽是在信号发射的线程中执行的。</li>
<li>队列连接的大概意思是：信号发射后当事件循环返回到接收线程时槽函数就执行了，也就是说这种连接方式不是立即触发槽函数的，而是要排队等的，并且是在槽函数的线程中执行。</li>
<li>自动连接的大概意思是：信号发射对象如果和槽的执行对象在同一个线程，那么将是直连方式，否则就是队列方式。</li>
<li>阻塞队列方式：在槽函数返回之前槽函数所在的线程都是阻塞的。</li>
<li>唯一方式：和直连相同，但是只能一对一连接。</li>
</ol>
<h4 id="需要注意的问题"><a href="#需要注意的问题" class="headerlink" title="需要注意的问题"></a>需要注意的问题</h4><ol>
<li>信号与槽的效率是非常高的，但是同真正的回调函数比较起来，由于增加了灵活性，因此在速度上还是有所损失，当然这种损失相对来说是比较小的，通过在一台i586-133的机器上测试是10微秒（运行Linux），可见这种机制所提供的简洁性、灵活性还是值得的。但如果我们要追求高效率的话，比如在实时系统中就要尽可能的少用这种机制。</li>
<li>信号与槽机制与普通函数的调用一样，如果使用不当的话，在程序执行时也有可能产生死循环。因此，在定义槽函数时一定要注意避免间接形成无限循环，即在槽中再次发射所接收到的同样信号。</li>
<li>如果一个信号与多个槽相关联的话，那么，当这个信号被发射时，与之相关的槽被激活的顺序将是随机的，并且我们不能指定该顺序。</li>
<li>宏定义不能用在signal和slot的参数中。</li>
<li>构造函数不能用在signals或者slots声明区域内。</li>
<li>函数指针不能作为信号或槽的参数。</li>
<li>信号与槽不能有缺省参数。</li>
<li>信号与槽也不能携带模板类参数。</li>
</ol>
<h4 id="Qt4中的信号槽"><a href="#Qt4中的信号槽" class="headerlink" title="Qt4中的信号槽"></a>Qt4中的信号槽</h4><p>&#160; &#160; &#160; Qt4中的信号槽是通过SIGNAL,SLOT两个宏,将参数转换成字符串.Qt编译前,会从源码的头文件中提取由signal和slot声明的信号和槽的函数，将其组成一张信号和槽对应的字符串表。</p>
<p>&#160; &#160; &#160; connect函数的作用是，将信号关联的槽字符串,同这张表的信息进行对比。这样信号发出的时候,就可以知道调用哪一个槽函数了。</p>
<p>&#160; &#160; &#160;没有编译期的检查:Qt4中的信号槽会被宏转化成字符串处理,而字符串的比较机制是在程序运行的时候检测的.而且,转换成字符串后,信号槽的参数数据类型就会丢失.这就导致,有的时候,信号槽在编译的时候没有问题,在运行的时候,反而出错。</p>
<p>&#160; &#160; &#160;无法使用相容类型的参数:因为信号槽的机制使用的是字符串的匹配的方法,所以,槽函数的参数类型的名字,必须和信号参数类型的名字一致,同时,还必须和头文件中声明的类型名字一致,也就是字符串意义上的严格相同.如果使用了typdef或者namespace这样的类型,虽然实际的类型是一样的,但是由于字符串的名字不一样,所以Qt4中是会有错误的.如下伪代码示例(实际类型都是int,但因为按照字符串处理,所以Qt4中,编译前不能通过。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Qt信号槽机制&quot;&gt;&lt;a href=&quot;#Qt信号槽机制&quot; class=&quot;headerlink&quot; title=&quot;Qt信号槽机制&quot;&gt;&lt;/a&gt;Qt信号槽机制&lt;/h3&gt;&lt;p&gt;引用转载 &lt;a href=&quot;http://blog.csdn.net/qter_wd007/arti
    
    </summary>
    
      <category term="Qt" scheme="http://tusko.cn/categories/Qt/"/>
    
    
      <category term="总结" scheme="http://tusko.cn/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="Qt" scheme="http://tusko.cn/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>map or hash_map</title>
    <link href="http://tusko.cn/2017/11/11/map-or-hash-map/"/>
    <id>http://tusko.cn/2017/11/11/map-or-hash-map/</id>
    <published>2017-11-11T06:07:33.000Z</published>
    <updated>2017-11-11T06:25:18.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="map和hashmap的区别"><a href="#map和hashmap的区别" class="headerlink" title="map和hashmap的区别"></a>map和hashmap的区别</h4><ul>
<li>底层数据结构不同，map是红黑树，hashmap是哈希表</li>
<li>map元素可以自动按照键值排序，hashmap的各项操作平均时间复杂度接近常数</li>
<li>map是C++标准的一部而hashmap并不是</li>
</ul>
<p>&#160; &#160; &#160; &#160;选用map还是hash_map，关键是看关键字查询操作次数，以及你所需要保证的是查询总体时间还是单个查询的时间。如果是要很多次操作， 要求其整体效率，那么使用hash_map，平均处理时间短。如果是少数次的操作，使用 hash_map可能造成不确定的O(N)，那么使用平均处理时间相对较慢、单次处理时间恒定的map，考虑整体稳定性应该要高于整体效率，因为前提在操 作次数较少。如果在一次流程中，使用hash_map的少数操作产生一个最坏情况O(N)，那么hash_map的优势也因此丧尽了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;map和hashmap的区别&quot;&gt;&lt;a href=&quot;#map和hashmap的区别&quot; class=&quot;headerlink&quot; title=&quot;map和hashmap的区别&quot;&gt;&lt;/a&gt;map和hashmap的区别&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;底层数据结构不同，map是红黑树
    
    </summary>
    
      <category term="C++" scheme="http://tusko.cn/categories/C/"/>
    
    
      <category term="C++" scheme="http://tusko.cn/tags/C/"/>
    
      <category term="stl" scheme="http://tusko.cn/tags/stl/"/>
    
  </entry>
  
  <entry>
    <title>Thinking in C++读书笔记</title>
    <link href="http://tusko.cn/2017/11/11/Thinging-in-C-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://tusko.cn/2017/11/11/Thinging-in-C-读书笔记/</id>
    <published>2017-11-11T03:17:37.000Z</published>
    <updated>2017-11-11T06:03:16.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h4><ol>
<li>CRC 类职责协同卡片</li>
<li>XP 极限编程，“先写测试”“结对编程”</li>
<li>链接器如何查找库</li>
<li>当创建可执行程序时，链接器秘密创建某些模块，启动模块，包含了对程序的初始化例程，建立堆栈</li>
<li>内部链接   外部链接</li>
<li>内部链接 只对正在编译的文件创建存储空间，内部链接由static</li>
<li>外部链接为所有编译过的文件创建单独的内存空间</li>
<li>转换<br>a. static_cast 用于明确定义的转换，包括非强制转换，窄化变换，void*的强制变换，隐式类型转换，类层次静态定位<br>b. const_case 从const转换为非const或从volatile转换为非volatial<br>c. reinterpret_cast 最不安全的一种转换<br>d. dynamic_cast 向下类型转换  </li>
<li>asm关键字 允许在c++中写汇编代码</li>
<li>argv[0]程序本身的本身的路径和名字</li>
<li>函数指针  void(*funcPtr)(); 先右后左顺序读</li>
<li>分段编译 makefile</li>
<li>静态存储区 栈  堆<br>a. 静态内存<br>b. 栈<br>c. 堆</li>
<li>对void* 类型delete   不会调用析构函数</li>
<li>int const <em> q = new int[10]  或者 const int </em> q = new int [10] 相同  对*q限制</li>
<li>int *const q = new int [10] 对q限制</li>
<li>自定义内存分配系统，重载new和delete， new时，需要一个内存分配表</li>
<li>显式调用析构函数只发生在定位new</li>
<li>构造函数和析构函数每一层函数都会调用，通常的成员函数，只是这个函数被调用</li>
<li>对于成员对象，构造函数调用次序完全不受构造函数的初始化表达式表中的次序影响，次序由成员对象在类中的声明次序所决定</li>
<li>派生类中改变了成员函数参数列表和返回类型，隐藏其他未重载的</li>
<li>任何在类内部定义的函数自动地成为内敛函数</li>
<li>对于任何函数，编译器在它的符号表中放入函数类型，当编译器看到内敛函数和对内敛函数体的进行分析没有发现错误时，就将对应于函数体的代码放入符号表</li>
<li>构造函数和析构函数、赋值运算符布能被继承</li>
<li>继承中重写拷贝构造函数和赋值运算符，编译器会假定我们已知道所做的一切，并且不再像在默认构造函数中自动调用基类版本</li>
<li>静态成员函数：<br>a. 均和被继承到派生类中<br>b. 如果重新定义了一个静态成员，所有在基类中的其他重载函数会被隐藏<br>c. 静态成员函数不可以是虚函数</li>
<li>组合通常是希望新类内部具有已存在类的功能使用，不是希望已存在类作为它的接口</li>
<li>函数调用捆绑（函数体与函数调用相联系称为捆绑）</li>
<li>编译器对包含虚函数的类创建了一个表，放置虚函数的地址，在每个带有虚函数的表中，编译器秘密放置一个指针，指向这个表</li>
<li>当继承一个抽象类，必须实现所有的纯虚函数，否则继承出的类也是一个抽象类</li>
<li>纯虚函数禁止对抽象类的函数以传值方式调用，防止对象切片</li>
<li>如果不在构造函数初始化表达式表中显式调用基类构造函数，就调用默认构造函数</li>
<li>要为纯虚析构函数提供一个函数体</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;基础知识&quot;&gt;&lt;a href=&quot;#基础知识&quot; class=&quot;headerlink&quot; title=&quot;基础知识&quot;&gt;&lt;/a&gt;基础知识&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;CRC 类职责协同卡片&lt;/li&gt;
&lt;li&gt;XP 极限编程，“先写测试”“结对编程”&lt;/li&gt;
&lt;li&gt;链接器如何
    
    </summary>
    
      <category term="C++" scheme="http://tusko.cn/categories/C/"/>
    
    
      <category term="笔记" scheme="http://tusko.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="C++" scheme="http://tusko.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++PrimerPlus读书笔记</title>
    <link href="http://tusko.cn/2017/11/11/C-PrimerPlus%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://tusko.cn/2017/11/11/C-PrimerPlus读书笔记/</id>
    <published>2017-11-11T03:17:37.000Z</published>
    <updated>2017-11-11T05:43:25.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h4><blockquote>
<ol>
<li>.h文件为老式头文件，没有.h扩展名需要using namespace</li>
<li>声明变量:需要的内存以及该单元的名称</li>
<li>C++11   int  n = {1}; 初始化列表 int n {1};</li>
<li>A 65  a 97</li>
<li>wchar_t 扩展字符集 ，是一种整数类型,wcout处理宽字符流</li>
<li>用const 比define好，可以使用C++ 作用域规则将定义限制在特定的函数或者文件中，可调试</li>
<li>float a = 2.34E+22f ; float b = a+1 ;b的值等于a ,因为float只能表示数字前6位或者前7位</li>
<li>C++11 列表初始化 ,不允许缩窄,不允许将浮点转换为整型. char c  {11111};not allowed</li>
<li>计算表达式 整型提升</li>
<li>指针数组  const char * cities[Cities] = {} </li>
<li>DLL文件，动态链接库</li>
<li>如果一个操作数无符号，另一个操作数有符号 ，有符号操作数转换为无符号操作数 </li>
<li>强制类型转换  (long)a  ，long(a)  后者是纯粹C++形式</li>
<li>int a[500] = {0} 所有元素都为0   int a[500]={1} 只有第一个元素是1</li>
<li>cin.getline(name,20) 不保存换行符 ;cin.get() 不读取换行符 留在输入队列中</li>
<li>C++11 原始字符串  R””</li>
<li>函数通过将返回值复制到指定的CPU寄存器或内存单元中将其返回，调用程序查看内存单元</li>
<li>&amp;array(数组名)  返回整个数组的地址  array是int数组 长度为8  则返回32字节的内存块地址</li>
<li>尽可能使用const , const int <em>ps  ，不能 </em>ps = 1; int * const ps  不能修改指向，即不能ps++</li>
<li>int <em>ar2[4] 由4个指向int的指针组成的数组 ,int (</em>a)[4]是由一个指向由4个int组成的数组的指针</li>
<li>const double <em> (</em>pa[3])(const double <em>,int) = {f,f,f};  [] 优先级高于</em> , *p[3] 包含三个指针的数组</li>
<li>&amp;pa是整个数组的地址,pa和&amp;pa值相同,但是类型不同,&amp;pa+1内存块地址,要得到第一个元素的值， **&amp;pa</li>
<li>char *a=”wwww”有内置的结束符</li>
<li>函数指针 double (<em>pf)(int); 函数指针调用函数  (</em>pf)(5);</li>
<li>内联函数inline  程序不用跳到另一个位置执行代码,再跳回来</li>
<li>按值传递  按引用传递</li>
<li>右值引用 double &amp;&amp; ref  = std::sqrt(1);</li>
<li>函数重载 template &lt; typename T&gt;</li>
<li>模板中,显示具体化:对于给定的函数名,可以有非模板函数,模板函数,和显示具体化模板函数以及它们的重载版本</li>
<li>显式具体化:template &lt;&gt; void swap<job>(job &amp; , job &amp;); 指定使用这个模板  不会寻找其他的</job></li>
<li>显式实例化 template void swap<int>(int,int);  调用生成一个模板实例</int></li>
<li>重载解析过程：第一步，创建候选函数列表，其中包含与被调用函数的名称相同的函数和模板函数；第二步，使用候选函数列表创建可行函数列表；第三步，确定是否有最佳的可行函数，如果有就使用</li>
<li>char 到int  提升转换  , char 到float  标准转换</li>
<li>C++11 关键字  decltype(x+y) xpy = x+y  判断变量类型</li>
<li>单独编译:如果编写另一个程序，也需要使用这些函数，只需要包含头文件，并将函数文件添加到项目列表或make列表中</li>
<li>&lt;&gt;在存储标头文件的主机系统的文件系统中找，“ ”当前工作目录</li>
<li>单独编译：只需要将源码文件加入到项目中，不要加入头文件，也不要使用#include包含其他文件</li>
<li>C++11 四种方案存储数据:自动存储持续性 静态存储持续性 线程存储持续性 动态存储持续性</li>
<li>链接性 外部的名称可以在文件间共享,内部名称只能由一个文件中的函数共享</li>
<li>局部变量：先定义的高地址，后定义的低地址，栈 </li>
<li>整数类型内部：低地址存储低位，高地址存储高位 </li>
<li>类，结构体，数组：先定义的低地址，后定义的高地址</li>
<li>小端字节序指低字节数据存放在内存低地址处，高字节数据存放在内存高地址处</li>
<li>大端字节序是高字节数据存放在低地址处，低字节数据存放在高地址处</li>
<li>static 内部链接性</li>
<li>通常编译器使用三块独立的内存,一块用于静态变量，自动变量，动态存储</li>
<li>名称空间：声明区域 潜在作用域</li>
<li>命名空间：使用在已命名的的名称空间中声明的变量，而不是外部全局变量</li>
<li>类对象的默认访问控制为private，域解析运算符::</li>
<li>C++ 对重载运算符的限制 : 重载后的运算符至少有一个操作数是用户自定义的类型；不能违反运算符原来的句法规则；不能创建新运算符；有一些运算符不能重载</li>
<li>A a = b ; 等同于 A a  = A(b)  调用了复制构造函数</li>
<li>默认构造函数，默认析构函数，复制构造函数，赋值运算符，地址运算符</li>
<li>公有派生：基类的私有部分也将成为派生类的一部分，基类的公有方法成为派生类的公有方法。 私有派生：基类的公有成员和保护成员都成为派生类的私有成员</li>
<li>虚基类：使得从多个类派生出的对象只继承一个基类对象，class Singer:virtual public Worker  , 信息自动传递不起作用， 虚基类使用默认构造函数。 如不使用默认构造函数，就显示调用 SingingWaiter(const Worker &amp;wk,int p = 0 ,int v = Singer:other ) : Worker(wk),Waiter(wk,p),Singer(wk,v);</li>
<li>单继承，没有重新定义方法就使用最近祖先的定义， 在多继承中，用作用域解析运算符</li>
<li>虚二义性规则与访问规则无关 </li>
<li>指针栈 Stack&lt; char *&gt;  </li>
<li>默认类型模板参数  template&lt; class T1,class T2 = int &gt; , 可以为类模板类型参数提供默认值，但不能为函数模板参数提供默认值</li>
<li>模板具体化：隐式实例化  显式实例化  显示具体化 ，编译器在需要对象之前，不会生成类的隐式实例化 </li>
<li>显式实例化 template class ArrayTP&lt; string,100 &gt;;</li>
<li>显式具体化  template &lt;&gt; class Classname&lt; specialized-type-name &gt; {}; 以前版本这样写： class Classname&lt; specialized-type-name &gt;{};</li>
<li>模板用作参数 template&lt; template &lt; typename T&gt; class Thing&gt; ;  </li>
<li>C++11 template&lt; typename T&gt; using arrtype = std::array<t,12> ;  arrtype&lt; double &gt; ball ;</t,12></li>
<li>注意友元函数定义声明顺序  需要前向声明，另外有元是单向传递的</li>
<li>嵌套类类型受模板影响</li>
<li>栈解退 ，try块没有直接调用引发异常的函数，而是调用了对引发异常的函数进行调用的函数 ，程序释放栈中的内存，但不会在释放栈的第一个返回地址后停止，而是继续释放栈，直到找到一个位于try块</li>
<li>noexcept 指出函数不会发生异常</li>
<li>RTTI 是运行时阶段类型识别 ，dynamic_cast 运算符将指向基类的指针生成派生类的指针 （必须有virtual），typeid 返回一个指出对象类型的值，type_info 结构存储了有关特定类型的信息</li>
<li>dynamic_cast 向上转换 ，const_cast  改变值为const volatile ，用于执行只有一种用途的类型转换，去掉const，但仍然是不可以改变的（编译器常量特性，忘记具体术语了）</li>
<li>static_cast 向下向上都可以转换， reinterpret_cast  运算符用于天生危险的类型转换常用于指针转换  </li>
<li></li>
<li>智能指针 auto_ptr 、 unique_ptr（比auto_ptr更安全）、 shared_ptr(多个指针指向一个对象)</li>
<li>标准模板库 STL  表示容器、迭代器、函数对象 算法 </li>
<li>STL迭代器:输入迭代器、输出迭代器、正向迭代器、双向迭代器、随机访问迭代器</li>
<li>vector 数组的表示，提供了自动内存管理功能，可以动态改变vector对象的长度 在尾部添加和删除元素的时间是固定的，在头部或中间插入和删除线性时间</li>
<li>deque  两端插入和删除时间是固定的</li>
<li>list 任何位置插入和删除时间是固定的 </li>
<li>forward_list 单链表</li>
<li>queue  适配器类，不允许随机访问队列元素，不允许遍历队列 </li>
<li>priority_queue 也是适配器类，底层是vector </li>
<li>array C++11 没有定义调整容器大小的操作,没有push_back     </li>
<li>函数对象 也叫函数符 ；返回bool值的一元函数是谓词 </li>
<li>宽字符类型 wchar_t  C++ 输出是字节流 ,ostream 将二进制位转换为由字符字节组成的输出流 </li>
<li>cin 检查输入，跳过空白 直到遇到空白字符  </li>
<li>cin.clear() 某个状态位被设置，另外两个状态位被清除  setState不会影响其他位</li>
</ol>
</blockquote>
<h4 id="C-新标准"><a href="#C-新标准" class="headerlink" title="C++ 新标准"></a>C++ 新标准</h4><blockquote>
<ol>
<li>新类型 long long  ,unsigned long long </li>
<li>统一的初始化（初始化列表） 1防止缩窄；2 std::initializer_list</li>
<li>声明 1 auto；2 decltype  y的类型和x相同 decltype(x) y;定义模板时很有用的</li>
<li>3返回类型后置  auto f2(double, int) -&gt; double;</li>
<li>4模板别名 using =  可以用于模板具体化,但是typedef不能   </li>
<li>array(double,12) a1;</li>
<li>template &lt; typename T &gt; using arr12 = array<t,12>;</t,12></li>
<li>arr12 &lt; double &gt; a1 ; //就可以这样声明了  模板具体化</li>
<li>nullptr 空指针不会指向有效数据的指针  是指针类型 不能转换为整型转换 </li>
<li>智能指针 auto_ptr ,unique_ptr（比auto_ptr更安全）  shared_ptr  weak_ptr   </li>
<li>异常规范方面的修改 noexcept</li>
<li>作用域内枚举 enum class New1{never,sometimes,often,always}; 防止发生名称冲突</li>
<li>对类的修改 explicit ; 类内成员初始化 ; </li>
<li>模板和STL方面的修改  </li>
<li>(1基于范围的for循环  </li>
<li>(2 新的STL容器  forward_list  unordered_map unordered_multimap</li>
<li>(3 新的STL方法  cend()</li>
<li>(4 valarray升级 ,valarray 独立于STL开发的；valarray &lt; bool&gt; vbool = numbers &gt; 9 ; vbool[i]被设置成numbers[i] &gt; 9 </li>
<li>slice 起始索引 索引数 跨距 ,如果valarray &lt; int &gt;对象varint,varint[slice(1,4,3)] = 10 ,第1 4 7 10 元素都设置成10</li>
<li>(5摒弃export </li>
<li>(6尖括号 vector<list <="" int=""> &gt; vl;</list></li>
<li>右值引用关联到右值,可以出现在赋值表达式右边,但不能对其应用地址运算符的值,右值包括字面常量 x+y 等表达式以及返回值的函数</li>
<li>int x = 10 ; int &amp;&amp; r1 = 13 ; int &amp;&amp;r2 = x + y ; r2关联一个数值，将右值关联到右值引用导致该右值被存储到特定的位置 ,且可以获取该位置的地址</li>
<li>虽然不能将&amp;用于13,但是可以用于r1.</li>
<li>移动语义和右值引用 </li>
<li>移动语义实际上避免了移动原始数据,只是修改了记录 </li>
<li>移动构造函数解析:让移动语义发生,需要两个步骤,右值引用让编译器知道何时可使用移动语义</li>
<li>Useless two = one ;</li>
<li>Useless four(one + three)</li>
<li>移动语义消除额外工作 </li>
<li>C++11 新的类功能:原有默认构造函数 复制构造函数 复制赋值运算 析构函数</li>
<li>新增 移动构造函数 移动赋值运算 </li>
<li>默认的方法和禁用的方法 default, 提供了移动构造函数就没有自动创建默认的构造函数</li>
<li>关键字delete和将复制函数放在private中效果差不多</li>
<li>delete 可以用于禁止特定的转换  void redo(int) = delete ; </li>
<li>委托构造函数 继承构造函数 </li>
<li>管理虚方法:  override final(禁止派生类重新定义函数)</li>
<li>Lambda函数</li>
<li>[&amp;count] (int x){count += (x % 13 == 0);}</li>
<li>三种方法给STL算法传递信息: 函数指针 函数符 lambda  ,使用匿名函数—无需给函数命名</li>
<li>[] (double x)-&gt;double{int  y = x ; return x - y} 当lambda表达式一条返回语句时可以自动类型推断,但是多个语句不行</li>
<li>auto mod = [] (int x) {return x % 3 == 0; };</li>
<li>int count13 ;   for_each(numbers.begin(),numbers.end(),[&amp;count13] (int x){count13 += x % 13 == 0})按引用捕获</li>
<li>用模板调用不同函数 </li>
<li>template &lt; typename T ,typename F &gt;<br>T use_f(T v,F f)<br>{<br>a. //body<br>b. return f(v) ;<br>}</li>
<li>包装器function 重写上述程序 只使用use_f()的一个实例而不是5个  根据特征标</li>
<li>function<double(double)> ef1 = dub ; </double(double)></li>
<li>function<double(double)> ef2 = [] (double u){return u*u} ; </double(double)></li>
<li>可变参数模板<br>{<br>模板参数包 类型列表 char int const char*<br>函数参数包<br>展开参数包<br>递归<br>}</li>
<li>template <typename...args><br>void show_list1(Args_args)<br>{<br>…<br>}<br>Args 是模板参数包 args是函数参数包<br>template<typename t,typename...="" args=""><br>void show_list(const T &amp;value, const Args&amp;… args)<br>{<br>show_list(args);<br>}</typename></typename...args></li>
</ol>
</blockquote>
<h4 id="C-11-新增的其他功能"><a href="#C-11-新增的其他功能" class="headerlink" title="C++11 新增的其他功能"></a>C++11 新增的其他功能</h4><blockquote>
<ol>
<li>并行编程</li>
<li>新增库 random </li>
<li>chrono 时间间隔</li>
<li>typle 广义pair</li>
<li>radio 有理数</li>
<li>regex 正则表达式库</li>
<li>低级编程  抽象程度低</li>
<li>加强元编程</li>
<li>POD规则</li>
</ol>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;基础知识&quot;&gt;&lt;a href=&quot;#基础知识&quot; class=&quot;headerlink&quot; title=&quot;基础知识&quot;&gt;&lt;/a&gt;基础知识&lt;/h4&gt;&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;.h文件为老式头文件，没有.h扩展名需要using namespace&lt;/li&gt;
&lt;l
    
    </summary>
    
      <category term="C++" scheme="http://tusko.cn/categories/C/"/>
    
    
      <category term="笔记" scheme="http://tusko.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="C++" scheme="http://tusko.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++岗位要求</title>
    <link href="http://tusko.cn/2017/11/11/C-%E5%B2%97%E4%BD%8D%E8%A6%81%E6%B1%82/"/>
    <id>http://tusko.cn/2017/11/11/C-岗位要求/</id>
    <published>2017-11-11T02:44:17.000Z</published>
    <updated>2017-11-11T03:15:44.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一些常见C-研发岗位要求，校招复习参考"><a href="#一些常见C-研发岗位要求，校招复习参考" class="headerlink" title="一些常见C++研发岗位要求，校招复习参考"></a>一些常见C++研发岗位要求，校招复习参考</h4><ol>
<li>计算机基础知识扎实，有一定的编程经验；</li>
<li>熟悉（精通）C/C++编程、熟悉STL；</li>
<li>熟悉常用数据结构、算法；</li>
<li>熟悉tcp，udp，http等协议；</li>
<li>熟悉MySQL或其它同类数据库系统；</li>
<li>了解MYSQL及SQL语言、编程，了解NoSQL, key-value存储原理</li>
<li>具备良好的逻辑思维、综合分析能力，以及团队协作能力。有主动学习的能力和意愿，对技术研究有热情；</li>
<li>宏定义和展开，位操作</li>
<li>Win/Linux编程环境</li>
<li>多线程开发(并发编程: 锁,无锁编程等),多进程通信, 网络编程, 套接字模型, select，epoll</li>
<li>有在linux服务器环境下开发或者使用cocos，unity3d引擎开发游戏经验者优先</li>
<li>熟悉3个池类技术(内存池, 线程池, 连接池)</li>
<li>全面、扎实的软件知识结构，掌握操作系统、软件工程、设计模式、数据结构、数据库系统、网络安全等专业知识</li>
<li>了解分布式系统设计与开发、负载均衡技术，系统容灾设计，高可用系统等知识</li>
</ol>
<p>游戏开发方面（加分选项）：</p>
<ol>
<li>熟悉消息封包解包 常见做法. 了解protobuf, thrift, 了解一些RPC库.</li>
<li>然后根据服务端 提供的 服务类型 再进行专门的知识掌握, 如游戏服务端要熟悉lua/python脚本,以及一些地图,玩家,物品数据结构设计等等, 互联网的肯定要熟悉memcached,redis之类的缓存软件, 分布式系统知识</li>
</ol>
<p>了解、熟悉、精通、熟练使用含义是不通的哦，简历中也要注意；以上仅供参考</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;一些常见C-研发岗位要求，校招复习参考&quot;&gt;&lt;a href=&quot;#一些常见C-研发岗位要求，校招复习参考&quot; class=&quot;headerlink&quot; title=&quot;一些常见C++研发岗位要求，校招复习参考&quot;&gt;&lt;/a&gt;一些常见C++研发岗位要求，校招复习参考&lt;/h4&gt;&lt;ol
    
    </summary>
    
      <category term="C++" scheme="http://tusko.cn/categories/C/"/>
    
    
      <category term="总结" scheme="http://tusko.cn/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="C++" scheme="http://tusko.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>2017秋招小结</title>
    <link href="http://tusko.cn/2017/11/10/2017%E7%A7%8B%E6%8B%9B%E5%B0%8F%E7%BB%93/"/>
    <id>http://tusko.cn/2017/11/10/2017秋招小结/</id>
    <published>2017-11-10T10:24:00.000Z</published>
    <updated>2017-11-11T02:39:12.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>本人的秋招在10月中旬宣告结束了，拿到几个小offer，最后选择去上海某游戏公司，大佬太多，就不说具体公司了~<br>本文总结对秋招准备已经心路历程做一个简单的总结，后续会整理一下技术方面的学习。</p>
<p>开始时间：2017年8月<br>方向：C++研发<br>看过的书有：操作系统课本，计算机网络（谢希仁），TCP/IP详解卷1，Effective C++，Linux实践教程，STL源码剖析，数据结构和算法分析C++描述，剑指offer（推荐）<br>另外看过许多牛客网上大佬的面经，用处很大，拜谢！<br>tips：很多书都是囫囵吞枣，秋招结束后静下心来继续看书，编程。</p>
<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>开始准备时，甚至连操作系统的进程、线程都分不清，TCP三次握手也是忘得一干二净，只怪自己当时上课不扎实，虽然经过埋头复习掌握得差不多，仍然花费了很多时间。</p>
<ol>
<li>电话面试大疆，没有经验，自我介绍都结结巴巴，另外语速太快，面试的小哥应该在自我介绍后就没有兴趣面下去了哈哈，还是问了一些项目和笔试题，但是毫无疑问挂掉了。</li>
<li>现场面了一家金融公司，面试官是清华大佬，看着手机上的知识点随意问，指哪问哪，我在C++基础上跌了坑，但是在stl的容器答的较好，最后拿到一个薪资在重庆一般的offer，但是强制996有点那个，这家果断不考虑，毕竟只是试试水。</li>
<li>转眼到了9月中旬，看到成都91act待遇不错（尚未对游戏行业做了解），买了动车票去电子科大做笔试题（当时不知道脑子怎么想的哈哈），笔试的一百多人，其中一半是游戏策划岗位，一半研发岗，这时才了解还有游戏策划这个岗位~ ，做完笔试晚上11点睡在酒店里收到面试短信，也没有多开心，感觉是理所应当，晚上开始看游戏相关的知识点，只在酒店里睡了三个小时，第二天下午去面试，找面试的咖啡馆找了一个小时（路痴，导航还不准！！）一面技术面，面试官很nice，面试体验很好，像和朋友在沟通一样，得知游戏服务器开发岗只有我一个本科生通过笔试，其他都是研究生，我说我已经满足了！ 然后问了项目经历（准备不充分，问到关键处表达不清），在技术实力上确实欠缺很多，之后挂在HR面上，还是那句话第一次没经验，说了不该说的话！</li>
<li>刚回重庆两天收到面腾讯的面试（很意外，编程题只AC了一道，但是成绩不低），于是屁颠屁颠地去成都腾讯大厦面试去了，移动开发岗位（选错岗位！），问了问项目，讲了一些C++基础，差不多一个小时，然后就挂了。</li>
<li>突然觉的自己好菜，这时已经决定将找小公司了，到了国庆了，一个人在宿舍安心看书，也决定找游戏开发方向的岗位（游戏玩的还是蛮久的），看游戏开发相关的内容，最后10月中旬拿到三家游戏公司offer，看来选对方向还是蛮重要的！</li>
</ol>
<h2 id="面试知识点"><a href="#面试知识点" class="headerlink" title="面试知识点"></a>面试知识点</h2><p>进程线程联系区别<br>stl容器底层<br>C++虚表，多态，左值右值，引用和指针<br>排序算法的空间复杂度，时间复杂度<br>tcpip三次握手，四次挥手，半包，多包，滑动窗口<br>tcp、udp区别<br>死锁<br>数据库索引原理，数据库引擎<br>讲项目</p>
<p>C++方向知识点很零碎很基础，无非是操作系统网络语言，多看看面经笔经难度不大的，9月后做笔试就通过率很高了，腾讯、百度都拿到了面试机会，牛客网的选择题很有帮助。</p>
<p>游戏开发岗位面试官当然喜欢问游戏相关的问题，比如对于dota2如何同步，对吃鸡这个游戏的看法，还有游戏排行榜算法，A*寻路算法等等</p>
<h2 id="积累的经验"><a href="#积累的经验" class="headerlink" title="积累的经验"></a>积累的经验</h2><ul>
<li>不断完善修改自己的简历，要对简历上写的内容完全掌握，项目没有必要很详细描述，因为面试官会提问你的</li>
<li>面试时语速要慢，放松心态，与面试官的交流像和朋友交谈一样，在面试过程中提问也是蛮好的</li>
<li>遇到不了解的问题，不要毫无思考地说我不会！想一想有没有相关的知识点，回答一些沾边的内容</li>
<li>面试是双向互动，双向沟通，每场面试结束前面试官会说：“你有什么问题想问我”，这时千万不要问薪资待遇这些很蠢的问题，你可以提问你的意向岗位的业务，或者你擅长的东西面试官没有问到，你可以懂了装不懂提问他嘛！</li>
<li>想清楚再说，不要说不着边际的话，尤其HR面试时，小姐姐们擅长挖坑</li>
<li>每次面试的失利都要总结自身不足并且完善，面试时答不上的问题一定要搞清楚，不要把面试失败的原因归结到什么面试官在应付，通过面试是自己运气好，未通过并不是运气不好，面试是一个成长的过程</li>
<li>想要去一家公司，就要去了解它的企业文化，了解它的产品，了解应聘的岗位，比如游戏开发岗，就要了解学习游戏开发相关知识，做一个有准备的人，面试官喜欢已经开始的人，而不是准备、打算、计划！</li>
<li>做题做题做题，首先要通过笔试，才有面试机会</li>
<li>大学是个积累的过程，折腾的任何事情都是有用的，在面试中一定会体现的</li>
</ul>
<h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><p>会在博客总结一些知识点，学习游戏开发知识，夯实基础，多读些书，年后入职</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>签的offer也比较满意了，毕竟自己技术还是有些差，需要不断学习和提高自己，共勉加油！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;开始&quot;&gt;&lt;a href=&quot;#开始&quot; class=&quot;headerlink&quot; title=&quot;开始&quot;&gt;&lt;/a&gt;开始&lt;/h2&gt;&lt;p&gt;本人的秋招在10月中旬宣告结束了，拿到几个小offer，最后选择去上海某游戏公司，大佬太多，就不说具体公司了~&lt;br&gt;本文总结对秋招准备已经
    
    </summary>
    
      <category term="随笔" scheme="http://tusko.cn/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="总结" scheme="http://tusko.cn/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>游戏类型小记</title>
    <link href="http://tusko.cn/2017/03/10/%E6%B8%B8%E6%88%8F%E7%B1%BB%E5%9E%8B%E5%B0%8F%E8%AE%B0/"/>
    <id>http://tusko.cn/2017/03/10/游戏类型小记/</id>
    <published>2017-03-10T07:16:00.000Z</published>
    <updated>2017-11-11T02:56:03.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="RPG-Role-playing-Game∶角色扮演游戏"><a href="#RPG-Role-playing-Game∶角色扮演游戏" class="headerlink" title="RPG = Role-playing Game∶角色扮演游戏"></a>RPG = Role-playing Game∶角色扮演游戏</h4><p>&#160; &#160; &#160; &#160;由玩家扮演游戏中的一个或数个角色，有完整的故事情节的游戏。玩家可能会与冒险类游戏混淆，其实区分很简单，RPG游戏更强调的是剧情发展和个人体验，一般来说，RPG可分为日式和美式两种，主要区别在于文化背景和战斗方式。日式RPG多采用回合制或半即时制战斗，如《最终幻想》系列，大多国产中文RPG也可归为日式RPG之列，如大家熟悉的《仙剑》、《剑侠》等；美式RPG如《暗黑破坏神》系列。更详细的，可以根据战斗进行方式分类，将RPG分为动作角色扮演游戏（A.RPG，战斗方式为即时动作，典型就是《暗黑破坏神》）和战略角色扮演游戏 （S.RPG，战斗方式好象下棋，即我们常说的战棋类游戏，如《轩辕伏魔录》。</p>
<h4 id="ACT-Action-Game∶动作游戏"><a href="#ACT-Action-Game∶动作游戏" class="headerlink" title="ACT = Action Game∶动作游戏"></a>ACT = Action Game∶动作游戏</h4><p>&#160; &#160; &#160; &#160;玩家控制游戏人物用各种武器消灭敌人以过关的游戏，不追求故事情节，如熟悉的《超级玛里》、可爱的《星之卡比》、华丽的《波斯王子》等等。电脑上的动作游戏大多脱胎于早期的街机游戏和动作游戏如《魂斗罗》、《三国志》等，设计主旨是面向普通玩家，以纯粹的娱乐休闲为目的，一般有少部分简单的解谜成份，操作简单，易于上手，紧张刺激，属于”大众化”游戏。 </p>
<h4 id="AVG-Adventure-Game-∶冒险游戏"><a href="#AVG-Adventure-Game-∶冒险游戏" class="headerlink" title="AVG = Adventure Game ∶冒险游戏"></a>AVG = Adventure Game ∶冒险游戏</h4><p>&#160; &#160; &#160; &#160;由玩家控制游戏人物进行虚拟冒险的游戏。与RPG不同的是，AVG的特色是故事情节往往是以完成一个任务或解开某些迷题的形式出现的，而且在游戏过程中刻意强调谜题的重要性。AVG也可再细分为动作类和解迷类两种，动作类AVG可以包含一些格斗或射击成分如《生化危机》系列、《古墓丽影》系列、《恐龙危机》等；而解迷类AVG则纯粹依靠解谜拉动剧情的发展，难度系数较大，代表是超经典的《神秘岛》系列。 </p>
<h4 id="SLG-Strategy-Game∶策略游戏"><a href="#SLG-Strategy-Game∶策略游戏" class="headerlink" title="SLG = Strategy Game∶策略游戏"></a>SLG = Strategy Game∶策略游戏</h4><p>&#160; &#160; &#160; &#160;玩家运用策略与电脑或其它玩家较量，以取得各种形式胜利的游戏，或统一全国，或开拓外星殖民地。策略游戏可分为回合制和即时制两种，回合制策略游戏如大家喜欢的《三国志》系列、《樱花大战》系列；即时制策略游戏如《命令与征服》系列、《帝国》系列、《沙丘》等。后来有些媒体将模拟经营，即SIM（simulation）类游戏，如《模拟人生》、《模拟城市》、《过山车大亨》、《主题公园》和养成类游戏（TCG，如《世界足球经理》，《零波丽育成计划》等）也归到了SLG下。 </p>
<h4 id="RTS-Real-Time-Strategy-Game：即时战略游戏"><a href="#RTS-Real-Time-Strategy-Game：即时战略游戏" class="headerlink" title="RTS = Real-Time Strategy Game：即时战略游戏"></a>RTS = Real-Time Strategy Game：即时战略游戏</h4><p>&#160; &#160; &#160; &#160;本来属于策略游戏SLG的一个分支，但由于其在世界上的迅速风靡，使之慢慢发展成了一个单独的类型，知名度甚至超过了SLG，有点象现在国际足联和国际奥委会的关系。代表作有《魔兽争霸》系列、《帝国时代》系列、《星际争霸》等等。后来，从其上又衍生出了所谓”即时战术游戏”，多以控制一个小队完成任务的方式，突出战术的作用，以《盟军敢死队》为代表。 </p>
<h4 id="FGT-Fighting-Game∶格斗游戏"><a href="#FGT-Fighting-Game∶格斗游戏" class="headerlink" title="FGT = Fighting Game∶格斗游戏"></a>FGT = Fighting Game∶格斗游戏</h4><p>&#160; &#160; &#160; &#160;由玩家操纵各种角色与电脑或另一玩家所控制的角色进行格斗的游戏。按呈画技术可再分为2D和3D两种，2D格斗游戏有著名的《街霸》系列、《侍魂》系列、《拳皇》系列等；3D格斗游戏如《铁拳》、《高达格斗》等。此类游戏谈不上什么剧情，最多有个简单的场景设定，或背景展示，场景、人物、操控等也比较单一，但操作难度较大，主要依靠玩家迅速的判断和微操作取胜。 </p>
<h4 id="STG-SHOTING-GAME∶射击类游戏"><a href="#STG-SHOTING-GAME∶射击类游戏" class="headerlink" title="STG = SHOTING GAME∶射击类游戏"></a>STG = SHOTING GAME∶射击类游戏</h4><p>&#160; &#160; &#160; &#160;这里所说的射击类，并非是类似《VR战警》的模拟射击（枪战），而是指纯的飞机射击，由玩家控制各种飞行物(主要是飞机)完成任务或过关的游戏。此类游戏分为两种，一叫科幻飞行模拟游戏（Science-Simulation Game），非现实的，想象空间为内容，如《自由空间》、《星球大战》系列等；另一种叫真实飞行模拟游戏（Real- Simulation Game），以现实世界为基础，以真实性取胜，追求拟真，达到身临其境的感觉。如《王牌空战》系列、《苏-27》等等。另外，还有一些模拟其他的游戏也可归为STG，比如模拟潜艇的《猎杀潜航》，模拟坦克的《钢铁雄师》等。STG也可以按照视角版面分为：纵版、横版、主观视角。<br>&#160; &#160; &#160; &#160;纵版：最为常见，像街机中的《雷电》、《鲛鲛鲛》、《空牙》等，都堪称经典之作。<br>&#160; &#160; &#160; &#160;横版：横轴射击，如《沙罗曼蛇》系列、《战区88》都是这类。<br>主观视角：仿真，模拟战机就属此类。 </p>
<h4 id="FPS-First-Personal-Shooting-Game：第一人称视角射击游戏"><a href="#FPS-First-Personal-Shooting-Game：第一人称视角射击游戏" class="headerlink" title="FPS = First Personal Shooting Game：第一人称视角射击游戏"></a>FPS = First Personal Shooting Game：第一人称视角射击游戏</h4><p>&#160; &#160; &#160; &#160;严格来说它是属于动作游戏的一个分支，但和RTS一样，由于其在世界上的迅速风靡，使之展成了一个单独的类型，典型的有DOOM系列、QUAKE系列、《虚幻》、《半条命》、《CS》……不胜枚举。 </p>
<h4 id="PZL-Puzzle-Game∶益智类游戏"><a href="#PZL-Puzzle-Game∶益智类游戏" class="headerlink" title="PZL = Puzzle Game∶益智类游戏"></a>PZL = Puzzle Game∶益智类游戏</h4><p>&#160; &#160; &#160; &#160;Puzzle的原意是指以前用来培养儿童智力的拼图游戏，引申为各类有趣的益智游戏，总的来说适合休闲，最经典的嘛~就是大家耳熟能详的《俄罗斯方块》啦。 </p>
<h4 id="RCG-Racing-Game∶竞速游戏-也有称作为RAC的"><a href="#RCG-Racing-Game∶竞速游戏-也有称作为RAC的" class="headerlink" title="RCG = Racing Game∶竞速游戏 [也有称作为RAC的]"></a>RCG = Racing Game∶竞速游戏 [也有称作为RAC的]</h4><p>&#160; &#160; &#160; &#160;在电脑上模拟各类赛车运动的游戏，通常是在比赛场景下进行，非常讲究图像音效技术，往往是代表电脑游戏的尖端技术。惊险刺激，真实感强，深受车迷喜爱，代表作有《极品飞车》、《山脊赛车》、《摩托英豪》等。另一种说法称之为”Driving Game”。目前，RCG内涵越来越丰富，出现了另一些其他模式的竞速游戏，如赛艇的，赛马等。 </p>
<h4 id="SPT-Sports-Game∶体育类游戏"><a href="#SPT-Sports-Game∶体育类游戏" class="headerlink" title="SPT = Sports Game∶体育类游戏"></a>SPT = Sports Game∶体育类游戏</h4><p>&#160; &#160; &#160; &#160;在电脑上模拟各类竞技体育运动的游戏，花样繁多，模拟度高，广受欢迎，如《FIFA》系列、《NBA Live》系列、《实况足球》系列等。 </p>
<h4 id="TCG-育成游戏"><a href="#TCG-育成游戏" class="headerlink" title="TCG = 育成游戏"></a>TCG = 育成游戏</h4><p>&#160; &#160; &#160; &#160;以前GB系列泛用，现在一般大家都用 EDU（education）来指代该类游戏，以便于和“ Online Trading Card Game”区分开。<br>顾名思义，就是玩家模拟培养的游戏，如《明星志愿》、《美少女梦工厂》、《零波丽育成计划》等等。 </p>
<h4 id="CAG-Card-Game∶卡片游戏"><a href="#CAG-Card-Game∶卡片游戏" class="headerlink" title="CAG = Card Game∶卡片游戏"></a>CAG = Card Game∶卡片游戏</h4><p>&#160; &#160; &#160; &#160;玩家操纵角色通过卡片战斗模式来进行的游戏。丰富的卡片种类使得游戏富于多变化性，给玩家无限的乐趣，代表作有著名的《信长的野望》系列、《游戏王》系列，包括卡片网游《武侠Online》，从广意上说《王国之心》也可以归于此类。 </p>
<h4 id="TAB-Table-Game∶桌面游戏"><a href="#TAB-Table-Game∶桌面游戏" class="headerlink" title="TAB = Table Game∶桌面游戏"></a>TAB = Table Game∶桌面游戏</h4><p>&#160; &#160; &#160; &#160;顾名思义，是从以前的桌面游戏脱胎到电脑上的游戏，如各类强手棋（即掷骰子决定移动格数的游戏），经典的象《大富翁》系列；棋牌类游戏也属于TAB，如《拖拉机》、《红心大战》、《麻将》等等。 </p>
<h4 id="MSC-Music-Game∶音乐游戏"><a href="#MSC-Music-Game∶音乐游戏" class="headerlink" title="MSC=Music Game∶音乐游戏"></a>MSC=Music Game∶音乐游戏</h4><p>&#160; &#160; &#160; &#160;培养玩家音乐敏感性，增强音乐感知的游戏。伴随美妙的音乐，有的要求玩家翩翩起舞，有的要求玩家手指体操，例如大家都熟悉的跳舞机，就是个典型，目前的人气网游《劲乐团》也属其列。 </p>
<h4 id="LVG-Love-Game∶恋爱游戏"><a href="#LVG-Love-Game∶恋爱游戏" class="headerlink" title="LVG=Love Game∶恋爱游戏"></a>LVG=Love Game∶恋爱游戏</h4><p>&#160; &#160; &#160; &#160;玩家回到初恋的年代，回味感人的点点滴滴，模拟恋爱的游戏。恋爱不是游戏，但偏偏有恋爱游戏，目前的恋爱类游戏主要是为男性玩家服务的，也有个别女性向的。可以训练追求的技术，（和学会忍耐？）代表作有日本的《心跳回忆》系列、《思君》，国人的《青涩宝贝》、《秋忆》等。 </p>
<h4 id="ETC-etc-Game∶其他类游戏"><a href="#ETC-etc-Game∶其他类游戏" class="headerlink" title="ETC = etc. Game∶其他类游戏"></a>ETC = etc. Game∶其他类游戏</h4><p>&#160; &#160; &#160; &#160;指无法归结到已知种类中的游戏，常见于种类丰富的电视游戏，如音乐游戏、某些游戏的周边设定集（如《心跳回忆》屏保壁纸集）等，电脑游戏中较少出现，即使有也多是移植自电视游戏。其实你判定不了的就把它丢这里吧。 </p>
<h4 id="WAG-Wap-Game∶手机游戏"><a href="#WAG-Wap-Game∶手机游戏" class="headerlink" title="WAG=Wap Game∶手机游戏"></a>WAG=Wap Game∶手机游戏</h4><p>&#160; &#160; &#160; &#160;手机上的游戏。目前游戏随处可以玩，连手机也必带休闲游戏，网民最喜欢手机游戏的种类，益智类比率最高，其次依次为动作类、战略类、模拟类、射击类。列举几个手机游戏例子：《金属咆哮》、《FF7 前传》等. </p>
<h4 id="MUD-泥巴游戏"><a href="#MUD-泥巴游戏" class="headerlink" title="MUD = 泥巴游戏"></a>MUD = 泥巴游戏</h4><p>&#160; &#160; &#160; &#160;主要是依靠文字进行游戏的游戏，图形辅助。1978年，英国埃塞克斯大学的罗伊·特鲁布肖用DEC-10编写了世界上第一款MUD游戏——“MUD1”，是第一款真正意义上的实时多人交互网络游戏，这是一个纯文字的多人世界。（这可能就是MUD的命名来源吧？）其他代表作：《侠客行》、《子午线59》、《万王之王》。<br>MMORPG=Massively Multiplayer Online Role Playing Game∶大型多人在线角色扮演游戏<br>这个地球人都知道。举几个典型的例子：《网络创世纪》、《无尽的任务》、《A3》、《魔兽》、《轩辕Ⅱ》等！</p>
<h4 id="MOBA-multiplayer-online-battle-arena多人在线战斗擂台游戏"><a href="#MOBA-multiplayer-online-battle-arena多人在线战斗擂台游戏" class="headerlink" title="MOBA = multiplayer online battle arena多人在线战斗擂台游戏"></a>MOBA = multiplayer online battle arena多人在线战斗擂台游戏</h4><p>&#160; &#160; &#160; &#160;玩家被分为两队，通常每个玩家只能控制其中一队中的一名角色，以打垮对方队伍的阵地建筑为胜利条件。<br>但有些多人在线战斗竞技场游戏1个玩家可以控制2至3名角色[1][2]，或2位玩家控制1名角色[3]，例如风暴英雄中的失落的维京人、雷克萨与丘加利。</p>
<h4 id="MMO-Massively-Multiplayer-Online大型多人在线"><a href="#MMO-Massively-Multiplayer-Online大型多人在线" class="headerlink" title="MMO = Massively Multiplayer Online大型多人在线"></a>MMO = Massively Multiplayer Online大型多人在线</h4>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;RPG-Role-playing-Game∶角色扮演游戏&quot;&gt;&lt;a href=&quot;#RPG-Role-playing-Game∶角色扮演游戏&quot; class=&quot;headerlink&quot; title=&quot;RPG = Role-playing Game∶角色扮演游戏&quot;&gt;&lt;/a&gt;
    
    </summary>
    
      <category term="游戏" scheme="http://tusko.cn/categories/%E6%B8%B8%E6%88%8F/"/>
    
    
      <category term="游戏" scheme="http://tusko.cn/tags/%E6%B8%B8%E6%88%8F/"/>
    
      <category term="转载" scheme="http://tusko.cn/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>转载：游戏研发引擎对比</title>
    <link href="http://tusko.cn/2017/03/05/%E6%B8%B8%E6%88%8F%E7%A0%94%E5%8F%91%E5%BC%95%E6%93%8E%E5%AF%B9%E6%AF%94/"/>
    <id>http://tusko.cn/2017/03/05/游戏研发引擎对比/</id>
    <published>2017-03-05T06:02:00.000Z</published>
    <updated>2017-11-11T02:56:36.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="游戏研发引擎对比"><a href="#游戏研发引擎对比" class="headerlink" title="游戏研发引擎对比"></a>游戏研发引擎对比</h3><p>&#160; &#160; &#160; &#160;GameLook报道/随着手游的快速增长和游戏业的发展，选择合适的引擎已经变得越来越困难。很明显，对于开发商们来说，有着成功游戏开发历史的引擎是首选，但随着家用机与手游设备的变化，我们选择游戏研发引擎时必须从多个方面分析，以下是开发商们不可不知的10款引擎：</p>
<h4 id="Unity3D"><a href="#Unity3D" class="headerlink" title="Unity3D"></a>Unity3D</h4><p>Unity3D对于游戏开发者们来说是一个真正可以负担的起的引擎，具有其他引擎难以匹敌的用户量。更为重要的是，你只需要付费一次，而且，不管你的游戏如何成功，都不用担心Unity会分走你的收入。这对于很多开发商来说当然是非常具有吸引力对，尤其是初创公司和新入行的开发者们。以下是Unity引擎的优点和缺点：</p>
<p>优点：业内最具竞争力的授权条款；易于使用而且兼容所有游戏平台；开发者社区支持强大；学习门槛非常第；开发商使用率最高。</p>
<p>缺点：工具数量有限，所以开发商必须给自己创作工具；做复杂和多样化的效果比较耗时。</p>
<h4 id="虚幻引擎-UDK"><a href="#虚幻引擎-UDK" class="headerlink" title="虚幻引擎(UDK)"></a>虚幻引擎(UDK)</h4><p>数年以来，虚幻引擎一直是做高端EA游戏最受欢迎的引擎。《战争机器》、《蝙蝠侠：阿卡汉姆疯人院》（Batman: Arkham Asylum）、《质量效应》以及很多大作都是出自该引擎之手，以下是虚幻引擎的优点和缺点：</p>
<p>优点：开发商使用率较高，开发商社区支持支持强大，有视频教程和大量资源。最佳的引擎支持并且随时更新其他引擎平台的功能，每次更新都会增加新工具，而且管理相对容易，有些工具甚至小学生都会使用。兼容大多数平台，比如iOS、Android、Linux、Mac、Windows和大多数游戏主机。</p>
<p>缺点：授权条款只适合大作，商业授权价格为99美元，在游戏收入超过5万美元之后，必须支付25%的分成。也有一些开发者抱怨有些工具不好用，学习门槛较高。</p>
<h4 id="CryEngine-3"><a href="#CryEngine-3" class="headerlink" title="CryEngine 3"></a>CryEngine 3</h4><p>该游戏引擎以优质的画面输出获得了大量开发者认可，如果你要做视觉出色的游戏，这款引擎绝对是最理想的选择。不过，该引擎也有自己的问题。</p>
<p>优点：CryEngine 3可以让你的游戏更美丽，Flowgraph工具的美术编程能力非常强悍。该引擎具备最强悍的音频工具，所以音频策划和程序猿们非常喜欢。该游戏引擎还提供目前最为简单易用的AI代码技术，对于初入行的开发者，该引擎的UI触手可及。</p>
<p>缺点：免费榜缺乏客户支持；推出时间相对较晚，开发者社区还不够强大；学习门槛对于初入行这比较高。</p>
<h4 id="HeroEngine"><a href="#HeroEngine" class="headerlink" title="HeroEngine"></a>HeroEngine</h4><p>该引擎在MMO和在线游戏领域获得了非常高的人气，代表作《星球大战：旧共和国》。对于新入行的开发者以及初创公司来说，授权费用较高，不过，如果你有一个非常具备潜力的项目，该引擎还是非常值得考虑的。以下是使用该引擎之前需要考虑的优点与缺点：</p>
<p>优点：提供多个开放世界地图，而且可以实现无缝转换；提供相对完善的AI；地图工具简单易用，并且集成了多个工具；脚本强大，足够帮助开发者研发复杂的项目、获得需要的资源；可以通过HeroCloud支持客户服务器。</p>
<p>缺点：脚本引擎强大但不够直观；HeroEngine和HeroCloud对于初创公司来说成本较高；新开发者学习门槛较高。</p>
<h4 id="Rage-Engine"><a href="#Rage-Engine" class="headerlink" title="Rage Engine"></a>Rage Engine</h4><p>该引擎的用途非常多，比较知名的游戏包括GTA Ⅲ、GTA：Vice City、GTA：San Andreas和很多知名大作。以下是该引擎的一些优点和缺点：</p>
<p>优点：兼容与处理较大世界观和天气特效方面非常出色；复杂的AI设计方面领先其他引擎；非常适合多种玩法的游戏；网络编程速度非常快；非常具有吸引力的画质水平。</p>
<p>缺点：和其他顶级引擎相比界面比较差；对于键盘和鼠标控制优化做的不足。</p>
<h4 id="Project-Anarchy"><a href="#Project-Anarchy" class="headerlink" title="Project Anarchy"></a>Project Anarchy</h4><p>该引擎是一套完整的端到端游戏引擎和尖端移动设备工具组，受到很多游戏开发者赞誉，但同样具有一些缺点。</p>
<p>优点：提供免费的手游研发工具（主要平台，比如iOS、Android和Tizen）；拥有非常强悍的程序调试工具；非常活跃的开发者社区与论坛；编辑器非常强大；音频输出能力非常好；优秀的Havok AI；vForge为开发者提供大量的定制化选择。</p>
<p>缺点：不支持Mac和Linux开发环境；没有新手教学；对于初创公司来说成本较高。</p>
<h4 id="GameSalad"><a href="#GameSalad" class="headerlink" title="GameSalad"></a>GameSalad</h4><p>这款引擎据说是不用写代码就能做游戏。这并不是个噱头，该引擎的确支持这样的功能。不过GameSalad一些功能也并不好用。</p>
<p>优点：如果你想独立开发一款iPhone游戏，该引擎非常适合你；对于快速实现游戏想法来说，GameSalad是个不错的引擎；兼容流行的手游研发平台，比如Cocona和Moai。</p>
<p>缺点：研发工具限制性比较强；缺乏大量的iOS功能；不兼容所有的平台。</p>
<h4 id="App-Game-Kit"><a href="#App-Game-Kit" class="headerlink" title="App Game Kit"></a>App Game Kit</h4><p>该引擎是真正的跨平台研发工具，非常易用、简单，而且比较灵活。以下是该引擎的优缺点：</p>
<p>优点：可以为多平台写代码，包括Android、iOS、Windows、Mac和Linux；集成Design Environment，可以在任何设备调试；加入了IAP、AdMob以及Push等工具；AGK脚本非常强大。</p>
<p>缺点：使用者较少，所以学习起来相对较慢；BUG比较多；传感器或者GPS支持比较差。</p>
<h4 id="Cocos2D"><a href="#Cocos2D" class="headerlink" title="Cocos2D"></a>Cocos2D</h4><p>很多策划认为Cocos2D对于新入行的开发者来说不仅具备大量功能，而且非常容易上手。虽然该引擎比较复杂，但值得一提的是其功能和灵活性，以下是该引擎的优缺点：</p>
<p>优点：强大而且灵活；理论上来讲，你可以为自己的游戏加入所有的iOS功能；提供成熟的框架和多种工具；开源、免费，社区支持强大。</p>
<p>缺点：和同类引擎相比比较复杂；学习门槛相对较高；特别适合Mac或者iOS平台，不过并不是跨平台引擎。</p>
<p>如今人们在各种平台都玩游戏，比如主机、移动设备甚至是智能电视，所以，开发商在选择引擎的时候，需要找到适合自己技术并且能够满足目标市场要求的引擎，因此合适的引擎对于开发商们来说尤其重要，特别是新入行的开发者们。</p>
<p>转载自 <a href="http://www.gamelook.com.cn/2014/08/176661" target="_blank" rel="external">GameLook</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;游戏研发引擎对比&quot;&gt;&lt;a href=&quot;#游戏研发引擎对比&quot; class=&quot;headerlink&quot; title=&quot;游戏研发引擎对比&quot;&gt;&lt;/a&gt;游戏研发引擎对比&lt;/h3&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;GameLook报道/随着手游的快速增
    
    </summary>
    
      <category term="游戏" scheme="http://tusko.cn/categories/%E6%B8%B8%E6%88%8F/"/>
    
    
      <category term="转载" scheme="http://tusko.cn/tags/%E8%BD%AC%E8%BD%BD/"/>
    
      <category term="游戏引擎" scheme="http://tusko.cn/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>转载：游戏服务端架构发展史(上)</title>
    <link href="http://tusko.cn/2017/02/10/%E6%B8%B8%E6%88%8F%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%9E%B6%E6%9E%84%E5%8F%91%E5%B1%95%E5%8F%B2-%E4%B8%8A/"/>
    <id>http://tusko.cn/2017/02/10/游戏服务端架构发展史-上/</id>
    <published>2017-02-10T07:16:00.000Z</published>
    <updated>2017-11-11T02:55:53.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="游戏服务端架构发展史（上）"><a href="#游戏服务端架构发展史（上）" class="headerlink" title="游戏服务端架构发展史（上）"></a>游戏服务端架构发展史（上）</h3><p>《游戏服务端架构发展史》转载请著名出处：<a href="http://www.skywind.me/blog/archives/1265" target="_blank" rel="external">http://www.skywind.me/blog/archives/1265</a></p>
<h4 id="类型1：卡牌，跑酷等弱交互服务端"><a href="#类型1：卡牌，跑酷等弱交互服务端" class="headerlink" title="类型1：卡牌，跑酷等弱交互服务端"></a>类型1：卡牌，跑酷等弱交互服务端</h4><p>卡牌跑酷类因为交互弱，玩家和玩家之间不需要实时面对面PK，打一下对方的离线数据，计算下排行榜，买卖下道具即可，所以实现往往使用简单的 HTTP服务器：</p>
<p><img src="/image_save/弱交互型服务端.png" alt="弱交互型服务端"></p>
<p>登录时可以使用非对称加密（RSA, DH），服务器根据客户端uid，当前时间戳还有服务端私钥，计算哈希得到的加密 key 并发送给客户端。之后双方都用 HTTP通信，并用那个key进行RC4加密。客户端收到key和时间戳后保存在内存，用于之后通信，服务端不需要保存 key，因为每次都可以根据客户端传上来的 uid 和 时间戳 以及服务端自己的私钥计算得到。用模仿 TLS的行为，来保证多次 HTTP请求间的客户端身份，并通过时间戳保证同一人两次登录密钥不同。</p>
<p>每局开始时，访问一下，请求一下关卡数据，玩完了又提交一下，验算一下是否合法，获得什么奖励，数据库用单台 MySQL或者 MongoDB即可，后端的 Redis做缓存（可选）。如果要实现通知，那么让客户端定时15秒轮询一下服务器，如果有消息就取下来，如果没消息可以逐步放长轮询时间，比如30秒；如果有消息，就缩短轮询时间到10秒，5秒，即便两人聊天，延迟也能自适应。</p>
<p>此类服务器用来实现一款三国类策略或者卡牌及酷跑的游戏已经绰绰有余，这类游戏因为逻辑简单，玩家之间交互不强，使用 HTTP来开发的话，开发速度快，调试只需要一个浏览器就可以把逻辑调试清楚了。</p>
<h4 id="类型2：第一代游戏服务器-1978"><a href="#类型2：第一代游戏服务器-1978" class="headerlink" title="类型2：第一代游戏服务器 1978"></a>类型2：第一代游戏服务器 1978</h4><p>978年，英国著名的财经学校University of Essex的学生 Roy Trubshaw编写了世界上第一个MUD程序《MUD1》，在University of Essex于1980年接入 ARPANET之后加入了不少外部的玩家，甚至包括国外的玩家。《MUD1》程序的源代码在 ARPANET共享之后出现了众多的改编版本，至此MUD才在全世界广泛流行起来。不断完善的 MUD1的基础上产生了开源的 MudOS（1991），成为众多网游的鼻祖：</p>
<p><img src="/image_save/MUDOS1978.png" alt="MUDOS1978"></p>
<p>MUDOS采用 C语言开发，因为玩家和玩家之间有比较强的交互（聊天，交易，PK），MUDOS使用单线程无阻塞套接字来服务所有玩家，所有玩家的请求都发到同一个线程去处理，主线程每隔1秒钟更新一次所有对象（网络收发，更新对象状态机，处理超时，刷新地图，刷新NPC）。</p>
<p>游戏世界采用房间的形式组织起来，每个房间有东南西北四个方向可以移动到下一个房间，由于欧美最早的网游都是地牢迷宫形式的，因此场景的基本单位被成为 “房间”。MUDOS使用一门称为LPC的脚本语言来描述整个世界（包括房间拓扑，配置，NPC，以及各种剧情）。游戏里面的高级玩家（巫师），可以不断的通过修改脚本来为游戏添加房间以及增加剧情。早年 MUD1上线时只有17个房间，Roy Trubshaw毕业以后交给他的师弟 Richard Battle，在 Richard Battle手上，不断的添加各种玩法到一百多个房间，终于让 MUD发扬光大。</p>
<p>用户使用 Telnet之类的客户端用 Tcp协议连接到 MUDOS上，使用纯文字进行游戏，每条指令用回车进行分割。比如 1995年国内第一款 MUD游戏《侠客行》，你敲入：”go east”，游戏就会提示你：“后花园 – 这里是归云庄的后花园，种满了花草，几个庄丁正在浇花。此地乃是含羞草生长之地。这里唯一的出口是 north。这里有：花待 阿牧（A mu），还有二位庄丁（Zhuang Ding）”，然后你继续用文字操作，查看阿牧的信息：“look a mu”，系统提示：“花待 阿牧（A mu）他是陆乘风的弟子，受命在此看管含羞草。他看起来三十多岁，生得眉清目秀，端正大方，一表人才。他的武艺看上去【不是很高】，出手似乎【极轻】”。然后你可以选择击败他获得含羞草，但是你吃了含羞草却又可能会中毒死亡。在早期网上资源贫乏的时候，这样的游戏有很强的代入感。</p>
<p>用户数据保存在文件中，每个用户登录时，从文本文件里把用户的数据全部加载进来，操作全部在内存里面进行，无需马上刷回磁盘。用户退出了，或者每隔5分钟检查到数据改动了，都会保存会磁盘。这样的系统在当时每台服务器承载个4000人同时游戏，不是特别大的问题。从1991年的 MUDOS发布后，全球各地都在为他改进，扩充，退出新版本，随着 Windows图形机能的增强。1997游戏《UO》在 MUDOS的基础上为角色增加的x,y坐标，为每个房间增加了地图，并且为每个角色增加了动画，形成了第一代的图形网络游戏。</p>
<p>因为游戏内容基本可以通过 LPC脚本进行定制，所以MUDOS也成为名副其实的第一款服务端引擎，引擎一次性开发出来，然后制作不同游戏内容。后续国内的《万王之王》等游戏，很多都是跟《UO》一样，直接在 MUDOS上进行二次开发，加入房间的地图还有角色的坐标等要素，该架构一直为国内的第一代 MMORPG提供了稳固的支持，直到 2003年，还有游戏基于 MUDOS开发。</p>
<p>虽然后面图形化增加了很多东西，但是这些MMORPG后端的本质还是 MUDOS。随着游戏内容的越来越复杂，架构变得越来越吃不消了，各种负载问题慢慢浮上水面，于是有了我们的第二代游戏服务器。</p>
<h4 id="类型3：第二代游戏服务器-2003"><a href="#类型3：第二代游戏服务器-2003" class="headerlink" title="类型3：第二代游戏服务器 2003"></a>类型3：第二代游戏服务器 2003</h4><p>2000年后，网游已经脱离最初的文字MUD，进入全面图形化年代。最先承受不住的其实是很多小文件，用户上下线，频繁的读取写入用户数据，导致负载越来越大。随着在线人数的增加和游戏数据的增加，服务器变得不抗重负。同时早期 EXT磁盘分区比较脆弱，稍微停电，容易发生大面积数据丢失。因此第一步就是拆分文件存储到数据库去：</p>
<p><img src="/image_save/第二代游戏服务端初型.png" alt="第二代游戏服务端初型"></p>
<p>此时游戏服务端已经脱离陈旧的 MUDOS体系，各个公司在参考 MUDOS结构的情况下，开始自己用 C在重新开发自己的游戏服务端。并且脚本也抛弃了 LPC，采用扩展性更好的 Python或者 Lua来代替。由于主逻辑使用单线程模型，随着游戏内容的增加，传统单服务器的结构进一步成为瓶颈。于是有人开始拆分游戏世界，变为下面的模型：</p>
<p><img src="/image_save/第二代游戏服务端二型.png" alt="第二代游戏服务端二型"></p>
<p>游戏服务器压力拆分后得意缓解，但是两台游戏服务器同时访问数据库，大量重复访问，大量数据交换，使得数据库成为下一个瓶颈。于是形成了数据库前端代理（DB Proxy），游戏服务器不直接访问数据库而是访问代理，再有代理访问数据库，同时提供内存级别的cache。早年 MySQL4之前没有提供存储过程，这个前端代理一般和 MySQL跑在同一台上，它转化游戏服务器发过来的高级数据操作指令，拆分成具体的数据库操作，一定程度上代替了存储过程：</p>
<p><img src="/image_save/第二代游戏服务端三型.png" alt="第二代游戏服务端三型"></p>
<p>但是这样的结构并没有持续太长时间，因为玩家切换场景经常要切换连接，中间的状态容易错乱。而且游戏服务器多了以后，相互之间数据交互又会变得比较麻烦，于是人们拆分了网络功能，独立出一个网关服务 Gate（有的地方叫 Session，有的地方叫 LinkSvr之类的，名字不同而已）：</p>
<p><img src="/image_save/第二代游戏服务端四型.png" alt="第二代游戏服务端四型"></p>
<p>把网络功能单独提取出来，让用户统一去连接一个网关服务器，再有网关服务器转发数据到后端游戏服务器。而游戏服务器之间数据交换也统一连接到网管进行交换。这样类型的服务器基本能稳定的为玩家提供游戏服务，一台网关服务1-2万人，后面的游戏服务器每台服务5k-1w，依游戏类型和复杂度不同而已，图中隐藏了很多不重要的服务器，如登录和管理。这是目前应用最广的一个模型，到今天任然很多新项目会才用这样的结构来搭建。</p>
<p>人都是有惯性的，按照先前的经验，似乎把 MUDOS拆分的越开性能越好。于是大家继续想，网关可以拆分呀，基础服务如聊天交易，可以拆分呀，还可以提供web接口，数据库可以拆分呀，于是有了下面的模型：</p>
<p><img src="/image_save/第二代游戏服务端五型.png" alt="第二代游戏服务端五型"></p>
<p>这样的模型好用么？确实有成功游戏使用类似这样的架构，并且发挥了它的性能优势，比如一些大型 MMORPG。但是有两个挑战：每增加一级服务器，状态机复杂度可能会翻倍，导致研发和找bug的成本上升；并且对开发组挑战比较大，一旦项目时间吃紧，开发人员经验不足，很容易弄挂。</p>
<p>比如我见过某上海一线游戏公司的一个 RPG上来就要上这样的架构，我看了下他们团队成员的经验，问了下他们的上线日期，劝他们用前面稍微简单一点的模型。人家自信得很，认为有成功项目是这么做的，他们也要这么做，自己很想实现一套。于是他们义无反顾的开始编码，项目做了一年多，然后，就没有然后了。</p>
<p>现今在游戏成功率不高的情况下，一开始上一套比较复杂的架构需要考虑投资回报率，比如你的游戏上线半年内 PCU会去到多少？如果一个 APRG游戏，每组服务器5千人都到不了的话，那么选择一套更为贴近实际情况的结构更为经济。即使后面你的项目真的超过5千人朝着1万人目标奔的话，相信那个时候你的项目已经挣大钱了 ，你数着钱加着班去逐步迭代，一次次拆分它，相信心里也是乐开花的。</p>
<p>上面这些类型基本都是从拆分 MUDOS开始，将 MUDOS中的各个部件从单机一步步拆成分布式。虽然今天任然很多新项目在用上面某一种类似的结构。因为他们本质上都是对 MUDOS的分解，故将他们归纳为第二代游戏服务器。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;游戏服务端架构发展史（上）&quot;&gt;&lt;a href=&quot;#游戏服务端架构发展史（上）&quot; class=&quot;headerlink&quot; title=&quot;游戏服务端架构发展史（上）&quot;&gt;&lt;/a&gt;游戏服务端架构发展史（上）&lt;/h3&gt;&lt;p&gt;《游戏服务端架构发展史》转载请著名出处：&lt;a hre
    
    </summary>
    
      <category term="游戏" scheme="http://tusko.cn/categories/%E6%B8%B8%E6%88%8F/"/>
    
    
      <category term="游戏" scheme="http://tusko.cn/tags/%E6%B8%B8%E6%88%8F/"/>
    
      <category term="转载" scheme="http://tusko.cn/tags/%E8%BD%AC%E8%BD%BD/"/>
    
      <category term="服务器" scheme="http://tusko.cn/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>极大值极小值算法</title>
    <link href="http://tusko.cn/2016/10/06/%E6%9E%81%E5%A4%A7%E5%80%BC%E6%9E%81%E5%B0%8F%E5%80%BC%E7%AE%97%E6%B3%95/"/>
    <id>http://tusko.cn/2016/10/06/极大值极小值算法/</id>
    <published>2016-10-06T07:38:46.000Z</published>
    <updated>2017-11-11T03:00:07.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="算法简介"><a href="#算法简介" class="headerlink" title="算法简介"></a>算法简介</h3><h4 id="极大值极小值算法"><a href="#极大值极小值算法" class="headerlink" title="极大值极小值算法"></a>极大值极小值算法</h4><p>&#160; &#160; &#160; &#160;在计算机博弈中，极大极小搜索算法是一种简单常见、便于理解的启发式搜索。因此在介绍极大极小搜索之前，我们先来介绍启发式搜索。</p>
<p>&#160; &#160; &#160; &#160;盲目搜索解决可以穷尽的问题。但事实上，这种理论上可以穷尽的搜索问题并不常见，我们见到更多的搜索问题状态空间往往是无法穷尽的，因此此时就会使用启发式搜索。这种启发式搜索只搜索博弈树中的一部分，然后采用启发方式引导博弈往利于己方获胜的方向发展。计算机通常会研究并发现一系列规则来形成启发方式，然后选择出一条可以解决问题的最佳路径。</p>
<p>&#160; &#160; &#160; &#160;极大极小搜索是一种在有限深度内搜索的启发式搜索。这里，我们用一个形象的例子来说明极大极小搜索。甲、乙两位玩家玩一个不清楚规则的游戏。在游戏过程中，甲方希望获得尽可能高的分数，而乙方恰恰希望甲方获得尽可能低的分数。这个游戏过程即是说：甲方在玩游戏时应尽量让自己的分数变大，而乙方则尽量让甲方分数变低。游戏中甲、乙双方使分数极大极小的过程就是极大极小搜索。</p>
<p>&#160; &#160; &#160; &#160;极大极小值算法是根据零和博弈的特点，在与对手的博弈中，模拟整个博弈的过程。在己方的所有决策中找出相对于自己最大收益的决策；假设我方能知道对方的所有决策，根据我方判断，在对手的决策所有决策中找到使己方最小收益的决策。</p>
<p>以下为一棵极大极小值搜索树:</p>
<p><img src="/images/极大极小值算法_1.png" alt="极大极小值搜索树"></p>
<p>&#160; &#160; &#160; &#160;如上图所示，它是一棵以当前局面为根节点而展开的5层博弈树，我们把偶数层记为Max层，把奇数层记为Min层，当博弈树扩展到叶子节点后，自底向上，我们倒推每个节点的值。如果父节点是在Max层，通过比较后，将子节点中的最大值赋给它；而如果是在Min层，通过比较后，将它节点中的最小值赋给它。递归进行，最终可以得知根节点的哪个子节点能让自己的局面优势最大或者说让对方的哪个局面优势最小。</p>
<p>以下是一棵二人博弈树:<br><img src="/images/二人博弈树.png" alt="二人博弈树"></p>
<p>&#160; &#160; &#160; &#160;根节点为A，其子节点B、C、D分别为我方产生一种行为后形成的另一种局面，节点E、F、G、H、I分别是对方在其父节点上产生一种行为后形成的局面。<br>&#160; &#160; &#160; &#160;通过极大极小值算法对该博弈树进行搜索之前，首先需要对此博弈树的叶子节点进行估值，假设其叶子节点估值如下：</p>
<p><img src="/images/二人博弈树估值.png" alt="二人博弈树估值"></p>
<p>&#160; &#160; &#160; &#160;根据极大极小值算法的原理，在第三层为对方产生行为后形成的局面，取极小值。节点B取节点E、F、G中估值最小的，所以节点B的估值为节点G的估值，为-11；节点D的估值为节点H、I中估值最小的，为-999；在第二层中为我方产生行为后形成的局面，则取极大值。此时，节点B估值为-11，节点C估值为-100，节点D估值为-999。则取节点B、C、D中估值最大的，所以节点A取节点B的估值。最后，我方取的最终行为是产生节点B局面的行为。<br>&#160; &#160; &#160; &#160;另外，极大极小值算法是基于静态估值函数的，且其博弈树的深度是有限的，到设定的深度后需返回其叶子节点的估值。</p>
<p>极小值算法伪代码:<br><img src="/images/极小值算法伪代码.png" alt="极小值算法伪代码"></p>
<p>极大值算法伪代码:<br><img src="/images/极大值算法伪代码.png" alt="极大值算法伪代码"></p>
<h4 id="负极大值算法"><a href="#负极大值算法" class="headerlink" title="负极大值算法"></a>负极大值算法</h4><p>&#160; &#160; &#160; &#160;当极大极小搜索应用于双人棋类博弈时，负极大搜索算法是其的简单变形。根据博弈的定义，对于同一个盘面，甲方对其评估值总是乙方对其评估值的相反数。因此，当前盘面的落子一方需要从所有下一个盘面评估值的相反数中取极大值，而下一个盘面评估值必须按照对手来评估。并且，该搜索步骤对于甲、乙双方均适用。负极大搜索算法与极小极大搜索算法具有相同的复杂度，只是简化了代码量，并没有对搜索节点数目进行缩减，下面我们讨论的负极大值搜索算法就对树的节点进行了剪枝，减小了搜索复杂度。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;算法简介&quot;&gt;&lt;a href=&quot;#算法简介&quot; class=&quot;headerlink&quot; title=&quot;算法简介&quot;&gt;&lt;/a&gt;算法简介&lt;/h3&gt;&lt;h4 id=&quot;极大值极小值算法&quot;&gt;&lt;a href=&quot;#极大值极小值算法&quot; class=&quot;headerlink&quot; title=&quot;极
    
    </summary>
    
      <category term="计算机博弈" scheme="http://tusko.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8D%9A%E5%BC%88/"/>
    
    
      <category term="计算机博弈" scheme="http://tusko.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8D%9A%E5%BC%88/"/>
    
      <category term="算法" scheme="http://tusko.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="计算机博弈算法" scheme="http://tusko.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8D%9A%E5%BC%88%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>极大极小值算法-井字棋实现</title>
    <link href="http://tusko.cn/2016/08/30/%E6%9E%81%E5%A4%A7%E6%9E%81%E5%B0%8F%E5%80%BC%E4%BA%95%E5%AD%97%E6%A3%8B/"/>
    <id>http://tusko.cn/2016/08/30/极大极小值井字棋/</id>
    <published>2016-08-30T03:59:41.000Z</published>
    <updated>2017-11-11T02:55:19.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="项目说明"><a href="#项目说明" class="headerlink" title="项目说明"></a>项目说明</h3><p>&#160; &#160; &#160; &#160;在玩家之间玩井字棋，基本上只会出现平局的结果，那么如何让计算机也能模拟人那样，思考并择优下棋，便涉及到计算机博弈的相关知识了，主要知识如下:</p>
<ol>
<li>棋盘表示</li>
<li>博弈树</li>
<li>估值与搜索算法</li>
</ol>
<h4 id="棋盘表示"><a href="#棋盘表示" class="headerlink" title="棋盘表示"></a>棋盘表示</h4><p>对于井字棋，采用3*3的二维数组.<br>因为数组根据下标定位，访问数组任一点的复杂度为O(1).</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#define COM -1   </div><div class="line">#define MAN 1</div></pre></td></tr></table></figure>
<p>其中0,1,-1分别表示棋盘上的空位,人下棋,计算机下棋.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//棋盘  </div><div class="line">int board[3][3] = &#123; &#123; 0,0,0 &#125;,  </div><div class="line">                    &#123; 0,0,0 &#125;,  </div><div class="line">                    &#123; 0,0,0 &#125;  </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="博弈树"><a href="#博弈树" class="headerlink" title="博弈树"></a>博弈树</h4><p>其次,假设有两人对弈,我们将其中一位叫做甲,另一位叫做乙.假定现在该甲走棋,甲可以有40种走法(不论好坏),而对甲的任一走法,乙也可以有与之相对的若干种走法.然后又轮到甲走棋,对乙的走法甲又有若干种方法应对…如此往复</p>
<p>而所有这些走法罗列出来,在计算机中构成一棵博弈树,节点根部为棋局的初始局面,根的子节点为甲所有可能的走法构成的新局面,而这些子节点的子节点则是与之相对的乙所有可能的走法构成的局面.而这些节点的末梢,是结束的棋局,即甲胜或者乙胜或者是平局.示例图如下:</p>
<p><img src="/images/井字棋博弈树.png" alt="井字棋博弈树"></p>
<p>再者,计算机是不会像人那样思考的,要实现计算机的只能,必须依靠算法实现.最常见的算法便是搜索算法,即搜索所有可能出现的局面,在其中选择一个能获胜的局面下棋.但这样是不现实的,因为每一步棋产生的局面实在太多,如19路围棋,其走法用最顶级的计算机来算,算到地球毁灭都不一定算得完.而其他棋类也有类似的情况,计算机没有足够资源在可行时间内穷尽所有走法.</p>
<p>传统的搜索算法不可行,那么计算机要通过什么样的方式得到最优局面呢?</p>
<p>是剪枝算法,在搜索中依据一个函数对不必要搜索节点进行过滤,剪枝.这个函数即评估函数,这种搜索算法称为启发式搜索.</p>
<p>而评估函数的好坏直接决定搜索的效率快慢.</p>
<p>博弈树中最基础的搜索算法,是基于深度优先搜索的极大值极小值算法.这里的极大极小值算法是相对而言的,在某一局面中,若甲胜取极大,甲负取极小,则甲要选择评估函数值尽量大的局面,而乙正好相反.</p>
<p><strong>关于极大值极小值算法,可以参考[这篇文章].</strong></p>
<h4 id="井字棋的评估函数"><a href="#井字棋的评估函数" class="headerlink" title="井字棋的评估函数"></a>井字棋的评估函数</h4><p>评估函数没有定式,是否合理准确只有通过实战检验.假设一个新同学读学长写的代码场景,新同学可能会问,为什么这个估值为什么是0.5,而另一个程序是0.8呢?为什么你的程序这样评估局面,而网上的程序是那样子的?这就是仁者见仁,智者见智了,评估函数的实现与开发者的对棋牌规则了解程度、想法、心情不同而有所差异.但是只有抓住耗子的猫才是好猫~</p>
<p><strong>这里给出一种井字棋的评估函数:</strong><br>将当前局面填满自己的子,然后以有双方连成3棋子的行,列,斜相减得到的值来评估局面的好坏.代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">//评估函数  </div><div class="line">int evaluteMap() &#123;  </div><div class="line">  </div><div class="line">    bool flag = true;  </div><div class="line">    int i, j;  </div><div class="line">  </div><div class="line">    if (isWin() == COM)  </div><div class="line">        return MAX_NUM;//如果计算机赢了，返回最大值   </div><div class="line">    if (isWin() == MAN)  </div><div class="line">        return -MAX_NUM;//如果计算机输了，返回最小值   </div><div class="line"> </div><div class="line">    int count = 0;//该变量用来表示评估函数的值  </div><div class="line">                  //将棋盘中的空格填满自己的棋子，既将棋盘数组中的0变为1  </div><div class="line">    for (i = 0; i &lt; 3; i++)  </div><div class="line">        for (j = 0; j &lt; 3; j++)  </div><div class="line">        &#123;  </div><div class="line">            if (board[i][j] == 0)  </div><div class="line">                tempBoard[i][j] = COM;  </div><div class="line">            else  </div><div class="line">                tempBoard[i][j] = board[i][j];  </div><div class="line">        &#125;  </div><div class="line">    //电脑一方  </div><div class="line">    //计算每一行中有多少行的棋子连成3个的  </div><div class="line">    for (i = 0; i &lt; 3; i++)  </div><div class="line">        count += (tempBoard[i][0] + tempBoard[i][1] + tempBoard[i][2]) / 3;  </div><div class="line">    for (i = 0; i &lt; 3; i++)  </div><div class="line">        count += (tempBoard[0][i] + tempBoard[1][i] + tempBoard[2][i]) / 3;  </div><div class="line">    count += (tempBoard[0][0] + tempBoard[1][1] + tempBoard[2][2]) / 3;  </div><div class="line">    count += (tempBoard[2][0] + tempBoard[1][1] + tempBoard[0][2]) / 3;  </div><div class="line">  </div><div class="line">    //将棋盘中的空格填满对方的棋子，既将棋盘数组中的0变为-1  </div><div class="line">    for (i = 0; i &lt; 3; i++)  </div><div class="line">        for (j = 0; j &lt; 3; j++)  </div><div class="line">        &#123;  </div><div class="line">            if (board[i][j] == 0)  </div><div class="line">                tempBoard[i][j] = MAN;  </div><div class="line">            else tempBoard[i][j] = board[i][j];  </div><div class="line">        &#125;  </div><div class="line">    //对方  </div><div class="line">    //计算每一行中有多少行的棋子连成3个的  </div><div class="line">    for (i = 0; i &lt; 3; i++)  </div><div class="line">        count += (tempBoard[i][0] + tempBoard[i][1] + tempBoard[i][2]) / 3;  </div><div class="line">    for (i = 0; i &lt; 3; i++)  </div><div class="line">        count += (tempBoard[0][i] + tempBoard[1][i] + tempBoard[2][i]) / 3;  </div><div class="line">    count += (tempBoard[0][0] + tempBoard[1][1] + tempBoard[2][2]) / 3;  </div><div class="line">    count += (tempBoard[2][0] + tempBoard[1][1] + tempBoard[0][2]) / 3;  </div><div class="line">  </div><div class="line">    return count;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="程序实现"><a href="#程序实现" class="headerlink" title="程序实现"></a>程序实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div><div class="line">305</div><div class="line">306</div><div class="line">307</div><div class="line">308</div><div class="line">309</div><div class="line">310</div><div class="line">311</div><div class="line">312</div><div class="line">313</div><div class="line">314</div><div class="line">315</div><div class="line">316</div><div class="line">317</div><div class="line">318</div><div class="line">319</div><div class="line">320</div><div class="line">321</div><div class="line">322</div><div class="line">323</div><div class="line">324</div><div class="line">325</div><div class="line">326</div><div class="line">327</div><div class="line">328</div><div class="line">329</div><div class="line">330</div><div class="line">331</div><div class="line">332</div><div class="line">333</div><div class="line">334</div><div class="line">335</div><div class="line">336</div><div class="line">337</div><div class="line">338</div><div class="line">339</div><div class="line">340</div><div class="line">341</div><div class="line">342</div><div class="line">343</div><div class="line">344</div><div class="line">345</div><div class="line">346</div><div class="line">347</div><div class="line">348</div><div class="line">349</div><div class="line">350</div><div class="line">351</div><div class="line">352</div><div class="line">353</div><div class="line">354</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;conio.h&gt; </div><div class="line">#define COM -1 </div><div class="line">#define MAN 1</div><div class="line">#define STEP 9 </div><div class="line">#define DRAW 0 </div><div class="line">#define ROW 3 </div><div class="line">#define COL 3</div><div class="line">#define MAX_NUM 1000;</div><div class="line"></div><div class="line"></div><div class="line">struct Move</div><div class="line">&#123;</div><div class="line">	int x;</div><div class="line">	int y;</div><div class="line"></div><div class="line">&#125;;</div><div class="line"></div><div class="line">//棋盘</div><div class="line">int board[3][3] = &#123; &#123; 0,0,0 &#125;,</div><div class="line">					&#123; 0,0,0 &#125;,</div><div class="line">					&#123; 0,0,0 &#125;</div><div class="line">&#125;;</div><div class="line">int tempBoard[3][3] = &#123; &#123; 0,0,0 &#125;,</div><div class="line">						&#123; 0,0,0 &#125;,</div><div class="line">						&#123; 0,0,0 &#125;</div><div class="line">&#125;;</div><div class="line">//玩家</div><div class="line">int player = MAN;</div><div class="line">//最好的一步</div><div class="line">Move bestMove;</div><div class="line">//当前深度</div><div class="line">int currentDepth;</div><div class="line">//谁先走</div><div class="line">bool MAN_first = true;</div><div class="line"></div><div class="line"></div><div class="line">//判断输赢</div><div class="line">int isWin() &#123;</div><div class="line">	int i, j;</div><div class="line"></div><div class="line">	for (int i = 0; i &lt; 3; i++)</div><div class="line">	&#123;</div><div class="line">		if (board[i][0] + board[i][1] + board[i][2] == 3)</div><div class="line">			return 1;</div><div class="line">		else if (board[i][0] + board[i][1] + board[i][2] == -3)</div><div class="line">			return -1;</div><div class="line">	&#125;</div><div class="line">	for (int j = 0; j &lt; 3; j++)</div><div class="line">	&#123;</div><div class="line">		if (board[0][j] + board[1][j] + board[2][j] == 3)</div><div class="line">			return 1;</div><div class="line">		else if (board[0][j] + board[1][j] + board[2][j] == -3)</div><div class="line">			return -1;</div><div class="line">	&#125;</div><div class="line">	if (board[0][0] + board[1][1] + board[2][2] == 3 || board[0][2] + board[1][1] + board[2][0] == 3)</div><div class="line">		return 1;</div><div class="line">	else if (board[0][0] + board[1][1] + board[2][2] == -3 || board[0][2] + board[1][1] + board[2][0] == -3)</div><div class="line">		return -1;</div><div class="line">	else  return 0;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">//评估函数</div><div class="line">int evaluteMap() &#123;</div><div class="line"></div><div class="line">	bool flag = true;</div><div class="line">	int i, j;</div><div class="line"></div><div class="line">	if (isWin() == COM)</div><div class="line">		return MAX_NUM;//如果计算机赢了，返回最大值 </div><div class="line">	if (isWin() == MAN)</div><div class="line">		return -MAX_NUM;//如果计算机输了，返回最小值 </div><div class="line"></div><div class="line"></div><div class="line">	int count = 0;//该变量用来表示评估函数的值</div><div class="line">				  //将棋盘中的空格填满自己的棋子，既将棋盘数组中的0变为1</div><div class="line">	for (i = 0; i &lt; 3; i++)</div><div class="line">		for (j = 0; j &lt; 3; j++)</div><div class="line">		&#123;</div><div class="line">			if (board[i][j] == 0)</div><div class="line">				tempBoard[i][j] = COM;</div><div class="line">			else</div><div class="line">				tempBoard[i][j] = board[i][j];</div><div class="line">		&#125;</div><div class="line">	//电脑一方</div><div class="line">	//计算每一行中有多少行的棋子连成3个的</div><div class="line">	for (i = 0; i &lt; 3; i++)</div><div class="line">		count += (tempBoard[i][0] + tempBoard[i][1] + tempBoard[i][2]) / 3;</div><div class="line">	for (i = 0; i &lt; 3; i++)</div><div class="line">		count += (tempBoard[0][i] + tempBoard[1][i] + tempBoard[2][i]) / 3;</div><div class="line">	count += (tempBoard[0][0] + tempBoard[1][1] + tempBoard[2][2]) / 3;</div><div class="line">	count += (tempBoard[2][0] + tempBoard[1][1] + tempBoard[0][2]) / 3;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">	//将棋盘中的空格填满对方的棋子，既将棋盘数组中的0变为-1</div><div class="line">	for (i = 0; i &lt; 3; i++)</div><div class="line">		for (j = 0; j &lt; 3; j++)</div><div class="line">		&#123;</div><div class="line">			if (board[i][j] == 0)</div><div class="line">				tempBoard[i][j] = MAN;</div><div class="line">			else tempBoard[i][j] = board[i][j];</div><div class="line">		&#125;</div><div class="line">	//对方</div><div class="line">	//计算每一行中有多少行的棋子连成3个的</div><div class="line">	for (i = 0; i &lt; 3; i++)</div><div class="line">		count += (tempBoard[i][0] + tempBoard[i][1] + tempBoard[i][2]) / 3;</div><div class="line">	for (i = 0; i &lt; 3; i++)</div><div class="line">		count += (tempBoard[0][i] + tempBoard[1][i] + tempBoard[2][i]) / 3;</div><div class="line">	count += (tempBoard[0][0] + tempBoard[1][1] + tempBoard[2][2]) / 3;</div><div class="line">	count += (tempBoard[2][0] + tempBoard[1][1] + tempBoard[0][2]) / 3;</div><div class="line">	</div><div class="line">	return count;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">void makeMove(Move curMove)</div><div class="line">&#123;</div><div class="line">	board[curMove.x][curMove.y] = player;</div><div class="line">	player = (player == COM) ? MAN : COM;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void unMakeMove(Move curMove) &#123;</div><div class="line">	board[curMove.x][curMove.y] = 0;</div><div class="line">	player = (player == COM) ? MAN : COM;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//得到有空位的集合</div><div class="line">int getMoveList(Move moveList[]) &#123;</div><div class="line">	int moveCount = 0;</div><div class="line">	int i, j;</div><div class="line">	for (i = 0; i &lt; COL; i++)</div><div class="line">	&#123;</div><div class="line">		for (j = 0; j &lt; ROW; j++)</div><div class="line">		&#123;</div><div class="line">			if (board[i][j] == 0)</div><div class="line">			&#123;</div><div class="line">				moveList[moveCount].x = i;</div><div class="line">				moveList[moveCount].y = j;</div><div class="line">				moveCount++;</div><div class="line">			&#125;</div><div class="line"></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	return moveCount; //返回一共多少个空的位置 </div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">int miniMaxsearch(int depth)</div><div class="line">&#123;</div><div class="line">	int value;  //估值 </div><div class="line">	int bestValue = 0; //最好的估值</div><div class="line">	int moveCount = 0;</div><div class="line">	int i; int m, n;</div><div class="line">	Move moveList[9];//保存可以下子的位置</div><div class="line">	if (isWin() == COM || isWin() == MAN)</div><div class="line">	&#123;</div><div class="line">		return evaluteMap();  //一般是返回极大极小值</div><div class="line">	&#125;</div><div class="line">	//如果搜索深度耗尽 ， 返回估值 </div><div class="line">	if (depth == 0)</div><div class="line">	&#123;</div><div class="line">		return evaluteMap();</div><div class="line">	&#125;</div><div class="line"></div><div class="line"></div><div class="line">	//根据不同的玩家 进行赋值 </div><div class="line">	if (COM == player) &#123;</div><div class="line">		bestValue = -MAX_NUM;</div><div class="line">	&#125;</div><div class="line">	else if (MAN == player)</div><div class="line">	&#123;</div><div class="line">		bestValue = MAX_NUM;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	//一共多少步</div><div class="line">	moveCount = getMoveList(moveList);</div><div class="line"></div><div class="line">	for (i = 0; i &lt; moveCount; i++)</div><div class="line">	&#123;</div><div class="line">		Move curMove = moveList[i];</div><div class="line"></div><div class="line">		makeMove(curMove);</div><div class="line">		value = miniMaxsearch(depth - 1);</div><div class="line">		unMakeMove(curMove);</div><div class="line"></div><div class="line">		if (player == COM)</div><div class="line">		&#123;</div><div class="line">			if (value &gt; bestValue)</div><div class="line">			&#123;</div><div class="line">				bestValue = value;</div><div class="line">				if (depth == currentDepth)</div><div class="line">				&#123;</div><div class="line">					bestMove = curMove;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		else if (player == MAN)</div><div class="line">		&#123;</div><div class="line">			if (value &lt; bestValue)</div><div class="line">			&#123;</div><div class="line">				bestValue = value;</div><div class="line">				if (depth == currentDepth)</div><div class="line">				&#123;</div><div class="line">					bestMove = curMove;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">	 </div><div class="line">	return bestValue;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">//打印棋盘 电脑X  ，玩家O </div><div class="line">void printBoard() &#123;</div><div class="line">	int i, j;</div><div class="line">	for (i = 0; i &lt; COL; i++)</div><div class="line">	&#123;</div><div class="line">		printf(&quot;-------------\n&quot;);</div><div class="line">		for (j = 0; j &lt; ROW; j++)</div><div class="line">		&#123;</div><div class="line">			if (board[i][j] == COM)</div><div class="line">			&#123;</div><div class="line">				printf(&quot;| X &quot;);</div><div class="line">			&#125;</div><div class="line">			else if (board[i][j] == MAN)</div><div class="line">			&#123;</div><div class="line">				printf(&quot;| O &quot;);</div><div class="line">			&#125;</div><div class="line">			else</div><div class="line">			&#123;</div><div class="line">				printf(&quot;|   &quot;);</div><div class="line">			&#125;</div><div class="line"></div><div class="line">		&#125;</div><div class="line">		printf(&quot;|\n&quot;);</div><div class="line">	&#125;</div><div class="line">	printf(&quot;-------------\n&quot;);</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">void com_play() &#123;</div><div class="line">	miniMaxsearch(currentDepth);</div><div class="line">	board[bestMove.x][bestMove.y] = COM;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">void man_play() &#123;</div><div class="line">	int x, y;</div><div class="line">	printf(&quot;请输入位置坐标  e.g ：（0 0）为左上角 （2，2）为右下角 \n&quot;);</div><div class="line">	scanf(&quot;%d&quot;, &amp;x);</div><div class="line">	scanf(&quot;%d&quot;, &amp;y);</div><div class="line"></div><div class="line">	while (x &lt; 0 || x &gt; 2 || y &lt; 0 || y &gt; 2)</div><div class="line">	&#123;</div><div class="line">		printf(&quot;您输入的坐标错误，请重新输入:x:(0~2) , y:(0~2)\n&quot;);</div><div class="line">		scanf(&quot;%d&quot;, &amp;x);</div><div class="line">		scanf(&quot;%d&quot;, &amp;y);</div><div class="line">	&#125;</div><div class="line">	while (board[x][y] != 0)</div><div class="line">	&#123;</div><div class="line">		printf(&quot;该位置已有棋，请重新输入:\n&quot;);</div><div class="line">		scanf(&quot;%d&quot;, &amp;x);</div><div class="line">		scanf(&quot;%d&quot;, &amp;y);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	board[x][y] = MAN;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">void setFirst() &#123;</div><div class="line">	char c;</div><div class="line">	printf(&quot;\nDo you want to play first? y -你先走  , n-电脑先走&quot;);</div><div class="line">	for (c = getche(); c != &apos;Y&apos;&amp;&amp;c != &apos;y&apos;&amp;&amp;c != &apos;N&apos;&amp;&amp;c != &apos;n&apos;; c = getche());</div><div class="line">	if (c == &apos;n&apos; || c == &apos;N&apos;) &#123;</div><div class="line">		MAN_first = false;</div><div class="line">	&#125;</div><div class="line">	printf(&quot;\n&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">void main()</div><div class="line">&#123;</div><div class="line">	currentDepth = 9;</div><div class="line">	int step = 1;</div><div class="line">	setFirst();</div><div class="line">	printBoard();</div><div class="line"></div><div class="line">	if (MAN_first) &#123;</div><div class="line">		player = MAN;</div><div class="line">		for (step = 1; step &lt;= STEP; )</div><div class="line">		&#123;</div><div class="line">			man_play();</div><div class="line">			printBoard();</div><div class="line">			if (player == isWin()) &#123;</div><div class="line">				printf(&quot;您获胜了！！&quot;);</div><div class="line">				break;</div><div class="line">			&#125;</div><div class="line">			step++;</div><div class="line">			currentDepth--;</div><div class="line">			if (step == 10) &#123;</div><div class="line">				printf(&quot;平局 ~~~&quot;);</div><div class="line">				break;</div><div class="line">			&#125;</div><div class="line">			player = (player == COM) ? MAN : COM;</div><div class="line">			com_play();</div><div class="line">			printBoard();</div><div class="line">			if (player == isWin()) &#123;</div><div class="line">				printf(&quot;很遗憾，电脑赢啦！！！&quot;);</div><div class="line">				break;</div><div class="line">			&#125;</div><div class="line">			step++;</div><div class="line">			currentDepth--;</div><div class="line">			player = (player == COM) ? MAN : COM;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	else</div><div class="line">	&#123;</div><div class="line">		player = COM;</div><div class="line">		for (step = 1; step &lt;= STEP; )</div><div class="line">		&#123;</div><div class="line">			com_play();</div><div class="line"></div><div class="line">			printBoard();</div><div class="line">			if (player == isWin()) &#123;</div><div class="line">				printf(&quot;很遗憾，电脑赢啦！！！&quot;);</div><div class="line">				break;</div><div class="line">			&#125;</div><div class="line">			step++;</div><div class="line">			currentDepth--;</div><div class="line">			if (step == 10) &#123;</div><div class="line">				printf(&quot;平局 ~~~&quot;);</div><div class="line">				break;</div><div class="line">			&#125;</div><div class="line">			player = (player == COM) ? MAN : COM;</div><div class="line">			man_play();</div><div class="line">			printBoard();</div><div class="line">			if (player == isWin()) &#123;</div><div class="line">				printf(&quot;您获胜了！！&quot;);</div><div class="line">				break;</div><div class="line">			&#125;</div><div class="line">			step++;</div><div class="line">			currentDepth--;</div><div class="line">			player = (player == COM) ? MAN : COM;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	getch();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;项目说明&quot;&gt;&lt;a href=&quot;#项目说明&quot; class=&quot;headerlink&quot; title=&quot;项目说明&quot;&gt;&lt;/a&gt;项目说明&lt;/h3&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;在玩家之间玩井字棋，基本上只会出现平局的结果，那么如何让计算机也能模拟
    
    </summary>
    
      <category term="计算机博弈" scheme="http://tusko.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8D%9A%E5%BC%88/"/>
    
    
      <category term="计算机博弈" scheme="http://tusko.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8D%9A%E5%BC%88/"/>
    
      <category term="计算机博弈算法" scheme="http://tusko.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8D%9A%E5%BC%88%E7%AE%97%E6%B3%95/"/>
    
      <category term="编程" scheme="http://tusko.cn/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>基于经验的井字棋</title>
    <link href="http://tusko.cn/2016/08/17/%E5%9F%BA%E4%BA%8E%E7%BB%8F%E9%AA%8C%E7%9A%84%E4%BA%95%E5%AD%97%E6%A3%8B/"/>
    <id>http://tusko.cn/2016/08/17/基于经验的井字棋/</id>
    <published>2016-08-17T03:11:11.000Z</published>
    <updated>2017-11-11T02:55:04.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="井字棋介绍"><a href="#井字棋介绍" class="headerlink" title="井字棋介绍"></a>井字棋介绍</h3><p>&#160; &#160; &#160; &#160;井字棋，英文名叫Tic-Tac-Toe，是一种在3*3格子上进行的连珠游戏，和五子棋类似，由于棋盘一般不画边框，格线排成井字故得名。游戏需要的工具仅为纸和笔，然后由分别代表O和X的两个游戏者轮流在格子里留下标记（一般来说先手者为X）<br><img src="/images/井字棋.jpg" alt="井字棋"></p>
<h3 id="项目说明"><a href="#项目说明" class="headerlink" title="项目说明"></a>项目说明</h3><p>这是本人做的第一个关于计算机博弈的程序，用C语言实现了人机对弈，电脑走步是参考<a href="http://www.guokr.com/article/4754/" target="_blank" rel="external">这篇文章</a>，使用纯经验-占角策略，玩家最多与电脑平局，达到了预期效果</p>
<h3 id="电脑策略"><a href="#电脑策略" class="headerlink" title="电脑策略"></a>电脑策略</h3><p>本节引用自<a href="http://www.guokr.com/article/4754/" target="_blank" rel="external">http://www.guokr.com/article/4754/</a>，如有侵权，请联系我</p>
<h4 id="先手先占角"><a href="#先手先占角" class="headerlink" title="先手先占角"></a>先手先占角</h4><p>游戏开始后，先占上一个角（比如左下角吧），那么对方总共有五种本质不同的应对策略：占据靠近你的那条边，占据靠近你的那个角，占据远离你的那条边，占据远离你的那个角（即对角），以及占据正中央的位置。不可思议的是，在这五种策略中，前面四种都是陷阱——如果对方不慎选择了前面四种策略中的任意一种，他就必然输掉。</p>
<p><img src="/images/井字棋1.png" alt="Alt text"></p>
<p>上图显示了在这四种情况下你可以如何把对方一步步逼上绝路。假设对方走正下方，占据了一个靠近你的边（最左边的那个图），你就可以占据正中央来应对，逼迫对方不得不走右上角。这时，只需要在左上角放下一子，你就赢定了——图中出现了两条只差一子的连线，对方不可能兼顾得了。</p>
<p>右边几个图显示了对方第一步棋的其它几种走法。选择合适的位置应对他，都可以在下一步迫使对方只剩一种走法，接下来你便可以下出“一箭双雕”的棋，让对方无法彻底封杀你。</p>
<p>也就是说，当你占据棋盘一角后，在对方下一步棋的八个可选位置中，其中七个位置都是必输的，陷阱摆满了几乎整个棋盘。</p>
<p><img src="/images/井字棋2.png" alt="Alt text"></p>
<p>上图显示了在这四种情况下你可以如何把对方一步步逼上绝路。假设对方走正下方，占据了一个靠近你的边（最左边的那个图），你就可以占据正中央来应对，逼迫对方不得不走右上角。这时，只需要在左上角放下一子，你就赢定了——图中出现了两条只差一子的连线，对方不可能兼顾得了。</p>
<p>右边几个图显示了对方第一步棋的其它几种走法。选择合适的位置应对他，都可以在下一步迫使对方只剩一种走法，接下来你便可以下出“一箭双雕”的棋，让对方无法彻底封杀你。</p>
<p>也就是说，当你占据棋盘一角后，在对方下一步棋的八个可选位置中，其中七个位置都是必输的，陷阱摆满了几乎整个棋盘。在面对“先走一角”的诡异开局时，你的朋友说不准就会慌了手脚，没能冷静地占住中间，决定了必败的命运。</p>
<h4 id="后手还是先占角"><a href="#后手还是先占角" class="headerlink" title="后手还是先占角"></a>后手还是先占角</h4><p><img src="/images/井字棋3.png" alt="Alt text"></p>
<p>作为后行者，你遇到的往往是“先走中间”的经典开局。此时，千万别忘了，先占角仍然是一条金科玉律。如果你不慎走了某条边的位置，对方可就赢定了！对方可以向上面的第一幅图那样，在正右方下子应对，逼迫你把下一步棋落在正左方。此时，对方便可占据右上方的位置，同时产生出两条仅差一子的连线。右边三幅图则显示，如果你在角上应对，最终总会是一盘和棋。</p>
<h3 id="程序实现"><a href="#程序实现" class="headerlink" title="程序实现"></a>程序实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div><div class="line">305</div><div class="line">306</div><div class="line">307</div><div class="line">308</div><div class="line">309</div><div class="line">310</div><div class="line">311</div><div class="line">312</div><div class="line">313</div><div class="line">314</div><div class="line">315</div><div class="line">316</div><div class="line">317</div><div class="line">318</div><div class="line">319</div><div class="line">320</div><div class="line">321</div><div class="line">322</div><div class="line">323</div><div class="line">324</div><div class="line">325</div><div class="line">326</div><div class="line">327</div><div class="line">328</div><div class="line">329</div><div class="line">330</div><div class="line">331</div><div class="line">332</div><div class="line">333</div><div class="line">334</div><div class="line">335</div><div class="line">336</div><div class="line">337</div><div class="line">338</div><div class="line">339</div><div class="line">340</div><div class="line">341</div><div class="line">342</div><div class="line">343</div><div class="line">344</div><div class="line">345</div><div class="line">346</div><div class="line">347</div><div class="line">348</div><div class="line">349</div><div class="line">350</div><div class="line">351</div><div class="line">352</div><div class="line">353</div><div class="line">354</div><div class="line">355</div><div class="line">356</div><div class="line">357</div><div class="line">358</div><div class="line">359</div><div class="line">360</div><div class="line">361</div><div class="line">362</div><div class="line">363</div><div class="line">364</div><div class="line">365</div><div class="line">366</div><div class="line">367</div><div class="line">368</div><div class="line">369</div><div class="line">370</div><div class="line">371</div><div class="line">372</div><div class="line">373</div><div class="line">374</div><div class="line">375</div><div class="line">376</div><div class="line">377</div><div class="line">378</div><div class="line">379</div><div class="line">380</div><div class="line">381</div><div class="line">382</div><div class="line">383</div><div class="line">384</div><div class="line">385</div><div class="line">386</div><div class="line">387</div><div class="line">388</div><div class="line">389</div><div class="line">390</div><div class="line">391</div><div class="line">392</div><div class="line">393</div><div class="line">394</div><div class="line">395</div><div class="line">396</div><div class="line">397</div><div class="line">398</div><div class="line">399</div><div class="line">400</div><div class="line">401</div><div class="line">402</div><div class="line">403</div><div class="line">404</div><div class="line">405</div><div class="line">406</div><div class="line">407</div><div class="line">408</div><div class="line">409</div><div class="line">410</div><div class="line">411</div><div class="line">412</div><div class="line">413</div><div class="line">414</div><div class="line">415</div><div class="line">416</div><div class="line">417</div><div class="line">418</div><div class="line">419</div><div class="line">420</div><div class="line">421</div><div class="line">422</div><div class="line">423</div><div class="line">424</div><div class="line">425</div><div class="line">426</div><div class="line">427</div><div class="line">428</div><div class="line">429</div><div class="line">430</div><div class="line">431</div><div class="line">432</div><div class="line">433</div><div class="line">434</div><div class="line">435</div><div class="line">436</div><div class="line">437</div><div class="line">438</div><div class="line">439</div><div class="line">440</div><div class="line">441</div><div class="line">442</div><div class="line">443</div><div class="line">444</div><div class="line">445</div><div class="line">446</div><div class="line">447</div><div class="line">448</div><div class="line">449</div><div class="line">450</div><div class="line">451</div><div class="line">452</div><div class="line">453</div><div class="line">454</div><div class="line">455</div><div class="line">456</div><div class="line">457</div><div class="line">458</div><div class="line">459</div><div class="line">460</div><div class="line">461</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &quot;stdlib.h&quot;</div><div class="line">#include &quot;time.h&quot;</div><div class="line">#include&lt;ctype.h&gt;      </div><div class="line">#include&lt;conio.h&gt; </div><div class="line">#define MAN 1 </div><div class="line">#define COM -1</div><div class="line">#define MAN_WIN 100</div><div class="line">#define COM_WIN -100</div><div class="line">#define DRAW 0 //平局 </div><div class="line">#define NONE 0  </div><div class="line">#define POSITION 9</div><div class="line">#define STEP 9</div><div class="line">#define random(x) (rand()%(x)) //产生随机数</div><div class="line"></div><div class="line">int board[10];//棋盘 初始默认值为0</div><div class="line">int win_place_sum;</div><div class="line">int angle[4] = &#123; 1,3,7,9 &#125;;</div><div class="line">int edge[4] = &#123; 2,4,6,8 &#125;;</div><div class="line"></div><div class="line">//是否赢了 </div><div class="line">int isWin(int player)</div><div class="line">&#123;</div><div class="line">if (board[1] == player &amp;&amp; board[1] == board[2] &amp;&amp; board[2] == board[3]) return(player);</div><div class="line">if (board[4] == player &amp;&amp; board[4] == board[5] &amp;&amp; board[5] == board[6]) return(player);</div><div class="line">if (board[7] == player &amp;&amp; board[7] == board[8] &amp;&amp; board[8] == board[9]) return(player);</div><div class="line">if (board[1] == player &amp;&amp; board[1] == board[4] &amp;&amp; board[4] == board[7]) return(player);</div><div class="line">if (board[2] == player &amp;&amp; board[2] == board[5] &amp;&amp; board[5] == board[8]) return(player);</div><div class="line">if (board[3] == player &amp;&amp; board[3] == board[6] &amp;&amp; board[6] == board[9]) return(player);</div><div class="line">if (board[1] == player &amp;&amp; board[1] == board[5] &amp;&amp; board[5] == board[9]) return(player);</div><div class="line">if (board[3] == player &amp;&amp; board[3] == board[5] &amp;&amp; board[5] == board[7]) return(player);</div><div class="line">//没人赢返回0</div><div class="line">return NONE;</div><div class="line">&#125;</div><div class="line">int isAngle(int position)</div><div class="line">&#123;</div><div class="line">if (position == 1 || position == 3 || position == 7 || position == 9)</div><div class="line">return position;</div><div class="line">return 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int isEdge(int position)</div><div class="line">&#123;</div><div class="line">if (position == 2 || position == 4 || position == 6 || position == 8)</div><div class="line">return position;</div><div class="line">return 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//两子成线，返回一个必须要下的位置 </div><div class="line">int checkWinning(int player) &#123;</div><div class="line">int i;</div><div class="line">int win_place = 10;</div><div class="line">win_place_sum = 0;</div><div class="line"></div><div class="line"></div><div class="line">for (i = 1; i &lt; 10; i++) &#123;</div><div class="line">if (board[i] == NONE) &#123;</div><div class="line">board[i] = player; //先假设该处有子进行判断 </div><div class="line">if (isWin(player) == player) &#123;</div><div class="line">board[i] = 0;</div><div class="line">win_place = i;</div><div class="line">win_place_sum++;</div><div class="line">&#125;</div><div class="line">board[i] = 0;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">return win_place;//返回下棋的位置</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">//电脑哥们进行下棋</div><div class="line">int com_play(int step , int lastPosition)</div><div class="line">&#123;</div><div class="line">int i;</div><div class="line"></div><div class="line">//随机数</div><div class="line">int ranNumber; </div><div class="line"></div><div class="line"></div><div class="line">//设置随机数种子</div><div class="line">srand((unsigned int)time(NULL));</div><div class="line"></div><div class="line"></div><div class="line">//第一步电脑走的位置</div><div class="line">int lastComPosition = 0;</div><div class="line"></div><div class="line"></div><div class="line">//能赢的地方</div><div class="line">int win_place = 10;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">int max_win_times = 0;</div><div class="line">//如果第一步，那么电脑先占角</div><div class="line">if ( ( step == 1 ) &amp;&amp; (lastPosition == 0 )) &#123;</div><div class="line">ranNumber = random(4);</div><div class="line">board[angle[ranNumber]] = COM;</div><div class="line">return angle[ranNumber];</div><div class="line">&#125;</div><div class="line">else if (step == 3)</div><div class="line">&#123;</div><div class="line"></div><div class="line">//第二步玩家走角</div><div class="line">if (isAngle(lastPosition) &gt; 0)</div><div class="line">&#123;</div><div class="line">for (i = 0; i &lt; 4; i++)</div><div class="line">&#123;</div><div class="line">if (board[angle[i]] == COM)</div><div class="line">&#123;</div><div class="line">lastComPosition = angle[i];</div><div class="line">// printf(&quot;第一步电脑走的是%d&quot;, lastComPosition);</div><div class="line">break; </div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">//如果走的是靠近边的角,就占对角</div><div class="line">if ((lastPosition + lastComPosition) != 10)</div><div class="line">&#123;</div><div class="line">if (board[10 - lastComPosition] == NONE)</div><div class="line">&#123;</div><div class="line">board[10 - lastComPosition] = COM;</div><div class="line">return 10 - lastComPosition;</div><div class="line">&#125;</div><div class="line">else</div><div class="line">&#123;</div><div class="line">printf(&quot;出错了——1&quot;);</div><div class="line">return 0;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">//如果走的是对角,那么就占其他的角</div><div class="line">else</div><div class="line">&#123;</div><div class="line">while (true)</div><div class="line">&#123;</div><div class="line">ranNumber = random(4);</div><div class="line">if (board[angle[ranNumber]] == NONE)</div><div class="line">&#123;</div><div class="line">board[angle[ranNumber]] = COM;</div><div class="line">return angle[ranNumber];</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">//第二步玩家走的是边</div><div class="line">else if( isEdge(lastPosition) &gt; 0 ) </div><div class="line">&#123;</div><div class="line">if(board[5] == NONE)</div><div class="line">&#123;</div><div class="line">board[5] = COM;</div><div class="line">return 5; </div><div class="line">&#125;</div><div class="line">else</div><div class="line">&#123;</div><div class="line">printf(&quot;中间5被占用了 ...&quot;);</div><div class="line">return 0; </div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">&#125;</div><div class="line">//如果走的是正中间 ，那么电脑走对角</div><div class="line">else if(lastPosition == 5 )</div><div class="line">&#123;</div><div class="line">for (i = 0; i &lt; 4; i++)</div><div class="line">&#123;</div><div class="line">if (board[angle[i]] == COM)</div><div class="line">&#123;</div><div class="line">lastComPosition = angle[i];</div><div class="line">// printf(&quot;第一步电脑走的是%d&quot;, lastComPosition);</div><div class="line">break;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">if (board[10 - lastComPosition] == NONE)</div><div class="line">&#123;</div><div class="line">board[10 - lastComPosition] = COM;</div><div class="line">return 10 - lastComPosition;</div><div class="line">&#125;</div><div class="line">else</div><div class="line">&#123;</div><div class="line">printf(&quot;出错了——2&quot;);</div><div class="line">return 0;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">else if (step == 5)</div><div class="line">&#123;</div><div class="line">win_place = checkWinning(COM);//电脑两子成线</div><div class="line">if (win_place &lt; 10)</div><div class="line">&#123;</div><div class="line">board[win_place] = COM;</div><div class="line">return win_place;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">win_place = checkWinning(MAN); //玩家的棋两子成线</div><div class="line">if (win_place &lt; 10)</div><div class="line">&#123;</div><div class="line">board[win_place] = COM;</div><div class="line">return win_place;</div><div class="line">&#125;</div><div class="line">//如果没有能赢的地方,则占角</div><div class="line">else</div><div class="line">&#123;</div><div class="line">for (i = 0; i &lt; 4; i++)</div><div class="line">&#123;</div><div class="line">if (board[angle[i]] == NONE)</div><div class="line">&#123;</div><div class="line">board[angle[i]] = COM;</div><div class="line"></div><div class="line">if (checkWinning(COM) &lt; 10 &amp;&amp; max_win_times &lt; win_place_sum)</div><div class="line">&#123;</div><div class="line">max_win_times = win_place_sum; //能赢的次数</div><div class="line">win_place = angle[i];</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">board[angle[i]] = NONE;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">board[win_place] = COM;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">&#125;</div><div class="line">else if(step == 2 )</div><div class="line">&#123;</div><div class="line">if (board[5] == NONE)</div><div class="line">&#123;</div><div class="line">board[5] = COM;</div><div class="line">return 5;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">else</div><div class="line">while (true)</div><div class="line">&#123;</div><div class="line">ranNumber = random(4);</div><div class="line">if (board[angle[ranNumber]] == NONE )</div><div class="line">&#123;</div><div class="line">board[angle[ranNumber]] = COM;</div><div class="line">return angle[ranNumber];</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">else</div><div class="line">&#123;</div><div class="line">win_place = checkWinning(COM);//电脑两子成线</div><div class="line">if (win_place &lt; 10)</div><div class="line">&#123;</div><div class="line">board[win_place] = COM;</div><div class="line">return win_place;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">win_place = checkWinning(MAN); //玩家的棋两子成线</div><div class="line">if (win_place &lt; 10)</div><div class="line">&#123;</div><div class="line">board[win_place] = COM;</div><div class="line">return win_place;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">for (i = 1; i &lt;= 9; i++) &#123;</div><div class="line">if (board[i] == NONE)</div><div class="line">&#123;</div><div class="line">board[i] = COM;</div><div class="line">printf(&quot;最后一步？？&quot;);</div><div class="line">return i;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">&#125;</div><div class="line">printf(&quot;COM-error&quot;);</div><div class="line">return 10;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">//玩家进行下棋</div><div class="line">int person_play()</div><div class="line">&#123;</div><div class="line">int row;</div><div class="line">int col;</div><div class="line">int index;</div><div class="line"></div><div class="line"></div><div class="line">do</div><div class="line">&#123;</div><div class="line">printf(&quot;亲~轮到你走一步了!!!请输入行坐标和列坐标 如  1 1 为左上角第一个点  2 2 为正中间的点   （1和1之间有个空格，否则错误）&quot;);</div><div class="line">scanf(&quot;%d&quot;, &amp;row);</div><div class="line">scanf(&quot;%d&quot;, &amp;col);</div><div class="line">index = (row - 1) * 3 + col;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">if (board[index] == NONE)</div><div class="line">&#123;</div><div class="line">board[index] = MAN;</div><div class="line">return index;</div><div class="line">&#125;</div><div class="line">printf(&quot;输入的下标不合法 ，越界或者此处已经有棋子存在 !!!! 请重新输入下标 ：）&quot;);</div><div class="line"></div><div class="line"></div><div class="line">&#125; while (true);</div><div class="line"></div><div class="line"></div><div class="line">printf(&quot;MAN-error&quot;);</div><div class="line">return 10;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">//画棋盘</div><div class="line">void display()</div><div class="line">&#123;</div><div class="line">char board_dis[10] = &#123; &quot;&quot; &#125;;</div><div class="line">int i;</div><div class="line">for (i = 1; i &lt; 10; i++)</div><div class="line">&#123;</div><div class="line">if (board[i] == COM) &#123;</div><div class="line">board_dis[i] = &apos;X&apos;;</div><div class="line">&#125;</div><div class="line">if (board[i] == MAN) &#123;</div><div class="line">board_dis[i] = &apos;O&apos;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">&#125;</div><div class="line">for (i = 0; i &lt; 10; i++) &#123;</div><div class="line">printf(&quot;-&quot;);</div><div class="line">&#125;</div><div class="line">printf(&quot;\n|&quot;);</div><div class="line">for (i = 1; i &lt;= 3; i++) &#123;</div><div class="line">printf(&quot;%c |&quot;, board_dis[i]);</div><div class="line">&#125;</div><div class="line">printf(&quot;\n&quot;);</div><div class="line">for (i = 0; i &lt; 10; i++) &#123;</div><div class="line">printf(&quot;-&quot;);</div><div class="line">&#125;</div><div class="line">printf(&quot;\n|&quot;);</div><div class="line">for (i = 4; i &lt;= 6; i++) &#123;</div><div class="line">printf(&quot;%c |&quot;, board_dis[i]);</div><div class="line">&#125;</div><div class="line">printf(&quot;\n&quot;);</div><div class="line">for (i = 0; i &lt; 10; i++) &#123;</div><div class="line">printf(&quot;-&quot;);</div><div class="line">&#125;</div><div class="line">printf(&quot;\n|&quot;);</div><div class="line">for (i = 7; i &lt;= 9; i++) &#123;</div><div class="line">printf(&quot;%c |&quot;, board_dis[i]);</div><div class="line">&#125;</div><div class="line">printf(&quot;\n&quot;);</div><div class="line">for (i = 0; i &lt; 10; i++) &#123;</div><div class="line">printf(&quot;-&quot;);</div><div class="line">&#125;</div><div class="line">printf(&quot;\n&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">void main()</div><div class="line">&#123;</div><div class="line">char c;</div><div class="line">int i;</div><div class="line">int step = 1; </div><div class="line">int lastPosition = 0;</div><div class="line"></div><div class="line"></div><div class="line">for (i = 0; i&lt;30; i++)</div><div class="line">printf(&quot;*&quot;);</div><div class="line">printf(&quot;\n*hello,welcome to this game!!*\n&quot;);</div><div class="line">for (i = 0; i&lt;30; i++)</div><div class="line">printf(&quot;*&quot;);</div><div class="line">printf(&quot;\nDo you want to play first? y -你先走  , n-电脑先走&quot;);</div><div class="line">for (c = getche(); c != &apos;Y&apos;&amp;&amp;c != &apos;y&apos;&amp;&amp;c != &apos;N&apos;&amp;&amp;c != &apos;n&apos;; c = getche());</div><div class="line">if (c == &apos;Y&apos; || c == &apos;y&apos;) </div><div class="line">&#123; </div><div class="line">display();</div><div class="line">for (step = 1; step &lt;= STEP; )</div><div class="line">&#123;</div><div class="line">lastPosition = person_play();</div><div class="line">display();</div><div class="line">if (MAN == isWin(MAN))</div><div class="line">&#123;</div><div class="line">printf(&quot;恭喜您 ， 您获胜了 &quot;);</div><div class="line">break;</div><div class="line">&#125;</div><div class="line">step++;</div><div class="line">if (step == 10) &#123;</div><div class="line">break;</div><div class="line">&#125;</div><div class="line">lastPosition = com_play(step,lastPosition);</div><div class="line">display();</div><div class="line"></div><div class="line"></div><div class="line">if (COM == isWin(COM))</div><div class="line">&#123;</div><div class="line">printf(&quot;很遗憾 ，电脑获胜了 &quot;);</div><div class="line">break;</div><div class="line">&#125;</div><div class="line">step++;</div><div class="line">&#125;</div><div class="line">if (isWin(COM) == NONE &amp;&amp; isWin(MAN) == NONE &amp;&amp; step == 10)</div><div class="line">&#123;</div><div class="line">printf(&quot;平局&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">else if (c == &apos;N&apos; || c == &apos;n&apos;)</div><div class="line">&#123;</div><div class="line">for (step = 1; step &lt;= STEP; )</div><div class="line">&#123;</div><div class="line"></div><div class="line"></div><div class="line">lastPosition = com_play(step, lastPosition);</div><div class="line">display();</div><div class="line"></div><div class="line"></div><div class="line">if (COM == isWin(COM))</div><div class="line">&#123;</div><div class="line">printf(&quot;很遗憾 ，电脑获胜了 &quot;);</div><div class="line">break;</div><div class="line">&#125;</div><div class="line">step++;</div><div class="line"></div><div class="line"></div><div class="line">if (step == 10) &#123;</div><div class="line">break;</div><div class="line">&#125;</div><div class="line">lastPosition = person_play();</div><div class="line"></div><div class="line">if (MAN == isWin(MAN))</div><div class="line">&#123;</div><div class="line">printf(&quot;恭喜您 ， 您获胜了 &quot;);</div><div class="line">break;</div><div class="line">&#125;</div><div class="line">step++;</div><div class="line"></div><div class="line">&#125;</div><div class="line">if (isWin(COM) == NONE &amp;&amp; isWin(MAN) == NONE &amp;&amp; step == 10)</div><div class="line">&#123;</div><div class="line">printf(&quot;平局&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">getch();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;井字棋介绍&quot;&gt;&lt;a href=&quot;#井字棋介绍&quot; class=&quot;headerlink&quot; title=&quot;井字棋介绍&quot;&gt;&lt;/a&gt;井字棋介绍&lt;/h3&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;井字棋，英文名叫Tic-Tac-Toe，是一种在3*3格子上进
    
    </summary>
    
      <category term="计算机博弈" scheme="http://tusko.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8D%9A%E5%BC%88/"/>
    
    
      <category term="计算机博弈" scheme="http://tusko.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8D%9A%E5%BC%88/"/>
    
  </entry>
  
  <entry>
    <title>UCT搜索算法</title>
    <link href="http://tusko.cn/2016/02/10/UCT%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/"/>
    <id>http://tusko.cn/2016/02/10/UCT搜索算法/</id>
    <published>2016-02-10T08:05:00.000Z</published>
    <updated>2017-11-11T03:00:18.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="算法简介"><a href="#算法简介" class="headerlink" title="算法简介"></a>算法简介</h3><h4 id="多臂匪徒"><a href="#多臂匪徒" class="headerlink" title="多臂匪徒"></a>多臂匪徒</h4><p>&#160; &#160; &#160; &#160;UCT算法是UCB策略与蒙特卡罗规划的结合体，在UCB算法中加入蒙特卡罗就形成了我们要介绍的UCT搜索。因此在介绍UCT搜索之前，我们先来了解下UCB策略和蒙特卡罗规划。</p>
<p>&#160; &#160; &#160; &#160;首先，介绍下多臂匪徒问题。多臂匪徒问题就是说，有一个有K个拉手的老虎机，赌徒要从这些拉手中选出一个拉手，从而获得可能值为正值，0，负值的回报。在某个特定时间内，赌徒只能拉动一个拉手。当赌徒在老虎机面前时，他是没有任何头绪的。因为对他而言，每个拉手获得好的回报的概率是一样的，他也不知道该怎么选。他只能不断试探，发现拉手的规律后，推断哪个拉手获得的回报最大。为了让赌徒得到尽可能大的回报，我们需要找到一种策略，UCB策略就是这样一种可以解决多臂匪徒问题的策略。下面就是UCB策略的算法流程图：</p>
<p><img src="/image_save/多臂匪徒.png" alt="多臂匪徒"></p>
<h4 id="蒙特卡罗应用于博弈树"><a href="#蒙特卡罗应用于博弈树" class="headerlink" title="蒙特卡罗应用于博弈树"></a>蒙特卡罗应用于博弈树</h4><p>&#160; &#160; &#160; &#160;蒙特卡罗规划是以蒙特卡罗方法的一种规划。在蒙特卡规划罗建立的博弈树中，从初始状态开始，重复给出抽样，然后扩展到树中的每一个节点。在不围棋中，即是说在选点时，如果对可选点中找出一些较好的节点进行上万，上百万次地模拟，如果采用合适的评估函数 ，那么在这些节点就会聚集大量模拟。在计算机博弈中，蒙特卡罗规划通常用来解决棋子落点问题。蒙特卡罗规划的伪代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"> while 模拟时间未用完 do</div><div class="line">      从当前状态的子节点中选择一个节点</div><div class="line">      if 该节点是第一次被访问 then</div><div class="line">         利用蒙特卡罗评估，得出胜负结果</div><div class="line">          更新相关节点的方向次数和获胜次数</div><div class="line">      else </div><div class="line">          回到2</div><div class="line">      end if</div><div class="line"> end while</div><div class="line">利用合适的方式选择最后的决策结果</div></pre></td></tr></table></figure>
<h4 id="UCT算法原理"><a href="#UCT算法原理" class="headerlink" title="UCT算法原理"></a>UCT算法原理</h4><h5 id="UCT与蒙特卡罗区别"><a href="#UCT与蒙特卡罗区别" class="headerlink" title="UCT与蒙特卡罗区别"></a>UCT与蒙特卡罗区别</h5><p>&#160; &#160; &#160; UCT算法使<strong>UCB策略与蒙特卡罗规划相结合</strong>。它跟蒙特卡罗规则的区别：</p>
<ol>
<li>UCT算法对于可下子点的选择不是随机的，而是根据UCB值来选择的。如果可下点没有被访问，其UCB值无穷大，因为要使这些没有被访问的节点有机会被访问，以便遗漏掉好的可下点。如果可下点被访问过，根据UCB公式计算出UCB值。最终，我们选择UCB值最大的值作为可下点。</li>
<li>模拟结束后选择可下点时，不是根据根据胜率来进行判断，而是根据可下点的访问次数，哪个点被访问的次数最多，哪个点就是我们选择的最终结果。</li>
</ol>
<p>&#160; &#160; &#160; UCT算法通过迭代来逐渐扩展博弈树。逐渐扩展是指，对某一个节点来说，它并不是直接扩展子节点，然后计算结果，而是在扩展节点时先对有可能成为子节点的节点进行评估，然后根据评估结果对子节点排序，最后根据排序顺序扩展子节点。这个评估结果的值就是 上面提到的UCB值。</p>
<p>&#160; &#160; &#160; UCB值兼顾探勘(exploitation)和探测(exploration)，这体现在UCB值既要考虑胜率高的节点又要考虑很少被访问的节点。UCB探勘胜率高的好节点，来拓展搜索的深度，进一步确认该节点是好节点；探测很少被访问到的节点，来扩展搜索的宽度，寻找一开始没找到的好节点。</p>
<p>&#160; &#160; &#160; 由此可知，节点的胜率越高或者越少被访问，那么这个节点UCB值就越高。UCB公式如下：</p>
<h5 id="UCB公式"><a href="#UCB公式" class="headerlink" title="UCB公式"></a>UCB公式</h5><p><img src="/image_save/ucb公式.png" alt="ucb公式"></p>
<p>&#160; &#160; &#160;在这个公式中， Wi表示子节点i的胜利次数，Ni表示子节点 i的访问次数，Np表示节点 p 的访问次數，Cbias是一個常数。最后节点p 会选择分数最高的子节点。此公式左边是探勘的部分，分数越高表示此节点胜率越高，之后被访问的几率也越高。右边部分是探索的部分，当节点 p 访问次数增加后，其访问次数越低的子节点在此部分就会得到越高的评估值，使其有机会被访问到。常数 Cbias是用來決定要重探勘还是重探索。</p>
<h5 id="UCT流程图"><a href="#UCT流程图" class="headerlink" title="UCT流程图"></a>UCT流程图</h5><p><img src="/image_save/uct流程图.png" alt="uct流程图"></p>
<h3 id="UCT搜索伪代码"><a href="#UCT搜索伪代码" class="headerlink" title="UCT搜索伪代码"></a>UCT搜索伪代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">PlayRandGame: 双方根据规则随机交替落子</div><div class="line">UpdateTree:更新UctTree的节点访问次数及相关收益</div><div class="line">ExpandNode:扩展子节点</div><div class="line">UCT核心伪代码如下:</div><div class="line">UctNode UctPlay(UctTree tree)</div><div class="line">&#123;</div><div class="line">	UctNode *current = &amp;tree.m_node;//从UCT树中取出当前局面作当前节点</div><div class="line">	while(!OverTimeLimit())</div><div class="line">	&#123;//若未超过时间限制</div><div class="line">		if (current.HasChild())</div><div class="line">		&#123;//当前节点是叶子点</div><div class="line">			UctState state = PlayRandGame(*current);//进行蒙特卡罗模拟</div><div class="line">			UpdateTree(state);//根据随机模拟结果更新UctTree访问及收益</div><div class="line">			if (current.m_visitor &gt; N)</div><div class="line">			&#123;   //若该节点访问次数到一定次数N</div><div class="line">				ExpandNode(*current);//展开子节点</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		else</div><div class="line">		&#123;//当前节点不是叶子节点</div><div class="line">			current = FindBestChild(*current);//取UCB最大的子节点作当前节点</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	return tree.FindBestNode();返回树中访问次数最多的节点</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;算法简介&quot;&gt;&lt;a href=&quot;#算法简介&quot; class=&quot;headerlink&quot; title=&quot;算法简介&quot;&gt;&lt;/a&gt;算法简介&lt;/h3&gt;&lt;h4 id=&quot;多臂匪徒&quot;&gt;&lt;a href=&quot;#多臂匪徒&quot; class=&quot;headerlink&quot; title=&quot;多臂匪徒&quot;&gt;&lt;/a
    
    </summary>
    
      <category term="计算机博弈" scheme="http://tusko.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8D%9A%E5%BC%88/"/>
    
    
      <category term="计算机博弈" scheme="http://tusko.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8D%9A%E5%BC%88/"/>
    
      <category term="算法" scheme="http://tusko.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="计算机博弈算法" scheme="http://tusko.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8D%9A%E5%BC%88%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>AlphaBeta剪枝算法</title>
    <link href="http://tusko.cn/2016/01/03/alphabeta%E5%89%AA%E6%9E%9D%E7%AE%97%E6%B3%95/"/>
    <id>http://tusko.cn/2016/01/03/alphabeta剪枝算法/</id>
    <published>2016-01-02T16:00:02.000Z</published>
    <updated>2017-08-19T11:29:42.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="算法简介"><a href="#算法简介" class="headerlink" title="算法简介"></a>算法简介</h3><h4 id="AlphaBeta剪枝算法"><a href="#AlphaBeta剪枝算法" class="headerlink" title="AlphaBeta剪枝算法"></a>AlphaBeta剪枝算法</h4><p>&#160; &#160; &#160; &#160;极大极小值搜索算法计算的是整个博弈搜索树的复杂度，对国际跳棋而言假设每个局面只有9个走步，搜索10层的情况下就有9^10个博弈树节点需要探索，在优先的计算机资源下，无论从时间还是空间上来看，都是不可以接受的。AlphaBeta搜索算法就是用来解决来剪枝掉一些不必要的节点。 </p>
<p>&#160; &#160; &#160; &#160;Alpha-Beta剪枝算法是建立在MiniMax算法基础上的，其特点是在博弈树上进行搜索时加上了alpha剪枝和beta剪枝。以下为alpha剪枝和beta剪枝示例：</p>
<p><img src="/image_save/alpha剪枝.png" alt="alpha剪枝"></p>
<p><img src="/image_save/beta剪枝.png" alt="beta剪枝"></p>
<p>&#160; &#160; &#160; &#160;如上图，<strong>其中正方形节点取极大值，圆形节点取极小值</strong>。图（a）中节点B的估值为18,节点C取极小值，则取节点D、E、F中最小估值的。由于节点D的估值为16，则节点C取值小于等于16。但是最终节点A取极大值在节点B、C中，所以，节点A一定取的为节点B的值18。那么，节点E、F不必进行估值搜索。因此C-E，C-F分支及节点C的子节点的分支全部被alpha剪枝。</p>
<p>&#160; &#160; &#160; &#160;图(b)中节点B估值为8，节点C取极大值，取节点D、E、F中最大估值的。节点D的估值18，则节点C的估值大于或等于18。但是节点A取极小值，所以节点A取节点B的值。节点C的其他分支被beta剪枝。</p>
<p>&#160; &#160; &#160; &#160;Alpha-Beta 剪枝算法的效率很大程度上依赖于节点的排列，在理想状态的排序下,最大效率前提，可以使搜索节点的数量减小一半，这样就能提高搜索速率，从而使在相同时间下的搜索深度增加一倍。可能读者以为提升一层深度有什么了不起，如果了解指数爆炸我们就知道这是巨大的提升，带来的是更快的速率。</p>
<p>&#160; &#160; &#160; &#160;算法使用了两个值，分别为alpha和beta，alpha和beta的意义分别代表最佳得分的最小下界和最大上界，即是最好的值和最差的值。最初alpha，beta被设为无穷大和无穷小，伴随着搜索的不断进行，这个上界和下界在不断博弈的情况下逐渐收敛成为一个相对较优的值。</p>
<p>（1）任何max节点的alpha值大于其父节点的beta值，则把该节点剩余的枝剪下去，因为这说明该节点之前至少有一个节点alpha值比它的上界还要小，也就是无论如何这个值比现有最坏情况还要坏，对敌方而言，所以敌方不会选这个路径作为最好走步，反之如果选择了，则他选择的是更坏的走步。而父节点是min节点，所以这个节点显然不是min节点所想要的。或者说这个节点对对手非常有利。<br>（2）同理任何min节点的beta值小于父节点alpha值，则把该节点剩余的枝剪去。</p>
<h3 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">int Alpha_Beta(nDepth, nAlpha, nBeta)</div><div class="line">&#123;</div><div class="line">	int score;</div><div class="line">	if(Game Over)</div><div class="line">		return Eveluation;// 游戏结束返回估值</div><div class="line">	</div><div class="line">	if(nDepth == 0)</div><div class="line">		return Eveluation;// 叶子节点返回估值</div><div class="line">	</div><div class="line">	if(IsMini Node)// 当为取极小值的节点</div><div class="line">	&#123;</div><div class="line">		for(each possible move m)</div><div class="line">		&#123;</div><div class="line">			make move m;</div><div class="line">			score = Alpha_Beta(nDepth-1, nAlpha, nBeta);// 递归搜索子节点</div><div class="line">			unmake move m;</div><div class="line">			if(score &lt; nBeta)</div><div class="line">			&#123;</div><div class="line">				nBeta = score; // 取极小值</div><div class="line">				if(nAlpha &gt;= nBeta)// beta剪枝</div><div class="line">					return nAlpha;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	else</div><div class="line">	&#123;</div><div class="line">		for(each possible move m)</div><div class="line">		&#123;</div><div class="line">			make move m;</div><div class="line">			score = Alpha_Beta(nDepth-1, nAlpha, nBeta);// 递归搜索子节点</div><div class="line">			unmake move m;</div><div class="line">			if(score &gt; nAlpha)</div><div class="line">			&#123;</div><div class="line">				nAlpha = score; // 取极大值</div><div class="line">				if(nAlpha &gt;= nBeta)// alpha 剪枝</div><div class="line">					return nBeta;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	return nAlpha;// 返回极大值</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;算法简介&quot;&gt;&lt;a href=&quot;#算法简介&quot; class=&quot;headerlink&quot; title=&quot;算法简介&quot;&gt;&lt;/a&gt;算法简介&lt;/h3&gt;&lt;h4 id=&quot;AlphaBeta剪枝算法&quot;&gt;&lt;a href=&quot;#AlphaBeta剪枝算法&quot; class=&quot;headerlink
    
    </summary>
    
      <category term="计算机博弈" scheme="http://tusko.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8D%9A%E5%BC%88/"/>
    
    
      <category term="计算机博弈" scheme="http://tusko.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8D%9A%E5%BC%88/"/>
    
      <category term="计算机博弈算法" scheme="http://tusko.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8D%9A%E5%BC%88%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
